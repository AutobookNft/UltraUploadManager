{"version":3,"file":"file_upload_manager-DovZbd6U.js","sources":["../../../packages/ultra/uploadmanager/resources/ts/domElements.ts","../../../packages/ultra/uploadmanager/resources/ts/saveLocalTempFile.ts","../../../packages/ultra/uploadmanager/resources/ts/deleteTemporaryFiles.ts","../../../packages/ultra/uploadmanager/resources/ts/uploadUtils.ts","../../../packages/ultra/uploadmanager/resources/ts/scanFile.ts","../../../packages/ultra/uploadmanager/resources/ts/showEmoji.ts","../../../packages/ultra/uploadmanager/resources/ts/handlers/BaseUploadHandler.ts","../../../packages/ultra/uploadmanager/resources/ts/handlers/EGIUploadHandler.ts","../../../packages/ultra/uploadmanager/resources/ts/handlers/EPPUploadHandler.ts","../../../packages/ultra/uploadmanager/resources/ts/handlers/UtilityUploadHandler.ts","../../../packages/ultra/uploadmanager/resources/ts/hubFileController.ts","../../../packages/ultra/uploadmanager/resources/ts/uploading.ts","../../../packages/ultra/uploadmanager/resources/ts/validation.ts","../../../packages/ultra/uploadmanager/resources/ts/prepareFilesForUploadUI.ts","../../../packages/ultra/uploadmanager/resources/ts/realTimeUploadListener.ts","../../../packages/ultra/uploadmanager/resources/ts/file_upload_manager.ts"],"sourcesContent":["// domElements.ts\n\nexport const statusMessage = document.getElementById('status-message') as HTMLElement;\nexport const statusDiv = document.getElementById('status') as HTMLElement;\nexport const scanProgressText = document.getElementById('scan-progress-text') as HTMLElement;\nexport const progressBar = document.getElementById('progress-bar') as HTMLElement;\nexport const progressText = document.getElementById('progress-text') as HTMLElement;\nexport const uploadFilebtn = document.getElementById('file-label') as HTMLElement;\nexport const returnToCollectionBtn = document.getElementById('returnToCollection') as HTMLElement;\nexport const scanvirusLabel = document.getElementById('scanvirus_label') as HTMLElement;\nexport const scanvirus = document.getElementById('scanvirus') as HTMLInputElement;\nexport const virusAdvise = document.getElementById('virus-advise') as HTMLElement;\nexport const circleLoader = document.getElementById('circle-loader') as HTMLElement;\nexport const circleContainer = document.getElementById('circle-container') as HTMLElement;\nexport const uploadBtn = document.getElementById('uploadBtn') as HTMLButtonElement;\nexport const cancelUploadBtn = document.getElementById('cancelUpload') as HTMLButtonElement;\nexport const emojiElements = document.querySelectorAll('.emoji') as NodeListOf<HTMLElement>;\nconst csrfMeta = document.querySelector('meta[name=\"csrf-token\"]');\nif (!csrfMeta) {\n    throw new Error(\"Meta tag with csrf-token not found\");\n}\nexport const csrfToken = csrfMeta.getAttribute('content') as string;\nexport const collection = document.getElementById('collection') as HTMLElement;\n\n\nexport function getFiles(): FileList | null {\n    if (!document.getElementById('files')) {\n        return null\n    }\n    return (document.getElementById('files') as HTMLInputElement).files;\n}\n","import {\n    csrfToken\n} from './domElements';\n\ndeclare const window: any;\n\ntype FetchResponse = Response;\n\n/**\n * Saves a temporary file locally by making a POST request to the server.\n *\n * @param formData - The form data containing the file to upload.\n * @returns A promise that resolves to the response from the server.\n * @throws An error if the request fails or the response is not ok.\n */\nexport async function saveLocalTempFile(formData: FormData): Promise<FetchResponse> {\n    if (window.envMode === 'local') {\n        console.log('Inside saveLocalTempFile');\n    }\n\n    try {\n        const response = await fetch('/upload-temp', {\n            method: 'POST',\n            headers: {\n                'X-CSRF-TOKEN': csrfToken,\n                'Accept': 'application/json',\n            },\n            body: formData,\n        });\n\n        if (window.envMode === 'local') {\n            console.log('Inside saveLocalTempFile. Response:', response);\n        }\n\n        if (!response.ok) {\n            const result = await response.json();\n\n            if (window.envMode === 'local') {\n                console.log('Inside saveLocalTempFile. Result:', result);\n            }\n\n            const error = JSON.stringify(result.error);\n            if (window.envMode === 'local') {\n                console.log('Inside saveLocalTempFile. Error:', error);\n            }\n\n            throw new Error(error);\n        }\n\n        return response;\n\n    } catch (error: any) {\n\n        if (window.envMode === 'local') {\n            console.error('Error in saveLocalTempFile:', error);\n        }\n        throw error;\n\n    }\n}\n","import { csrfToken } from './domElements';\n\ndeclare const window: any;\n\n/**\n * Deletes a temporary file from Digital Ocean.\n *\n * @param file - The file to be deleted.\n * @returns A promise that resolves to the response from the server.\n * @throws An error if the request fails or the response is not ok.\n */\nexport async function deleteTemporaryFileExt(file: string): Promise<Response> {\n    if (window.envMode === 'local') {\n        console.log('Inside deleteTemporaryFileExt');\n    }\n\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('_token', csrfToken);\n\n    try {\n        const response = await fetch('/delete-temporary-file-DO', {\n            method: 'POST',\n            headers: {\n                'X-CSRF-TOKEN': csrfToken\n            },\n            body: formData\n        });\n\n        if (!response.ok) {\n            const result = await response.json();\n\n            if (window.envMode === 'local') {\n                console.log('Inside deleteTemporaryFileExt. Result:', result);\n            }\n\n            const error = JSON.stringify(result.error);\n            if (window.envMode === 'local') {\n                console.log('Inside deleteTemporaryFileExt. Error:', error);\n            }\n\n            throw new Error(error);\n        }\n\n        return response;\n\n    } catch (error: any) {\n        if (window.envMode === 'local') {\n            console.error('Error in deleteTemporaryFileDO:', error);\n        }\n        throw error;\n    }\n}\n\n/**\n * Deletes a temporary local file.\n *\n * @param file - The file to be deleted.\n * @returns A promise that resolves to the response from the server.\n * @throws An error if the request fails or the response is not ok.\n */\nexport async function deleteTemporaryFileLocal(file: File): Promise<Response> {\n    if (window.envMode === 'local') {\n        console.log('Inside deleteTemporaryFileLocal', file);\n    }\n\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('_token', csrfToken);\n\n    try {\n        const response = await fetch('/delete-temporary-file-local', {\n            method: 'POST',\n            headers: {\n                'X-CSRF-TOKEN': csrfToken,\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n\n        if (window.envMode === 'local') {\n            console.info('response:', response);\n            console.info('response.status:', response.status);\n        }\n\n        if (!response.ok) {\n            const result = await response.json();\n\n            if (window.envMode === 'local') {\n                console.log('Inside deleteTemporaryFileLocal. Result:', result);\n            }\n\n            throw result;\n        }\n\n        return response;\n\n    } catch (error: any) {\n\n        if (window.envMode === 'local') {\n            console.error('Error in deleteTemporaryFileLocal:', error);\n        }\n\n        throw error;\n    }\n}\n\n","/**\n * Helper functions for handling UI operations related to the upload process.\n * These functions include disabling/enabling buttons, removing emojis, updating status messages,\n * and handling image previews.\n */\n\nimport {\n    statusMessage,\n    statusDiv,\n    getFiles,\n    uploadBtn,\n    uploadFilebtn,\n    returnToCollectionBtn,\n    cancelUploadBtn,\n    emojiElements,\n    collection\n\n} from './domElements';\n\nconst files = getFiles() || [];\n\n\nexport function disableButtons(): void {\n\n    for (let i = 0; i < files.length; i++) {\n        const delFileBtn = document.getElementById(`button-${files[i].name}`);\n        if (delFileBtn) {\n            delFileBtn.style.display = 'none';\n        }\n    }\n\n    uploadFilebtn.style.display = 'none';\n    uploadBtn.style.display = 'none';\n    returnToCollectionBtn.style.display = 'none';\n    cancelUploadBtn.style.display = 'none';\n}\n\nexport function enableButtons(): void {\n\n    for (let i = 0; i < files.length; i++) {\n        const delFileBtn = document.getElementById(`button-${files[i].name}`);\n        if (delFileBtn) {\n            delFileBtn.style.display = 'inline-block';\n        }\n    }\n\n    cancelUploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');\n    uploadBtn.style.display = 'inline-block';\n    returnToCollectionBtn.style.display = 'inline-block';\n    cancelUploadBtn.style.display = 'inline-block';\n    uploadBtn.disabled = false;\n    uploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');\n    cancelUploadBtn.disabled = false;\n}\n\nexport function resetButtons(): void {\n\n    for (let i = 0; i < files.length; i++) {\n        const delFileBtn = document.getElementById(`button-${files[i].name}`);\n        if (delFileBtn) {\n            delFileBtn.style.display = 'inline-block';\n        }\n    }\n\n    uploadFilebtn.style.display = 'inline-block';\n    uploadBtn.style.display = 'inline-block';\n    uploadBtn.classList.add('opacity-50', 'cursor-not-allowed');\n    uploadBtn.disabled = true;\n    cancelUploadBtn.style.display = 'inline-block';\n    cancelUploadBtn.disabled = true;\n    cancelUploadBtn.classList.add('opacity-50', 'cursor-not-allowed');\n    returnToCollectionBtn.style.display = 'inline-block';\n    removeEmojy();\n}\n\nexport function removeEmojy(): void {\n    emojiElements.forEach((emoji) => {\n        emoji.remove();\n    });\n}\n\nexport function handleImage(index: number, event: { target: { result: string } }, files: FileList): void {\n    const div = document.createElement('div');\n    div.classList.add('relative', 'group');\n    (div as any).index = index;\n\n    div.innerHTML = `\n        <div class=\"relative group\" id=\"file-${files[index].name}\">\n        <img src=\"${event.target.result}\" alt=\"File Image\" class=\"w-full h-40 object-cover rounded-lg shadow-md transition-all duration-300 group-hover:scale-105 z-0\">\n        <button type=\"button\" id=\"button-${files[index].name}\" onclick=\"removeFile('${files[index].name}')\" class=\"bg-red-500 text-white absolute bottom-4 px-4 rounded-full text-sm hover:bg-red-700 z-10 hidden\">\n            ${window.btnDel}\n        </button>\n        <div class=\"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg\">\n            <p class=\"text-white text-sm\">File ${files[index].name}</p>\n        </div>\n    </div>`;\n    collection.appendChild(div);\n\n    if (window.envMode === 'local') {\n        console.log('File added:', files[index].name);\n    }\n}\nexport function updateStatusDiv(message: string, type: string = 'info'): void {\n    let colorClass = '';\n    let backgroundClass = '';\n\n    switch (type) {\n        case 'error':\n            colorClass = 'text-red-700';\n            backgroundClass = 'bg-red-200';\n            break;\n        case 'success':\n            colorClass = 'text-green-700';\n            backgroundClass = 'bg-green-200';\n            break;\n        case 'info':\n            colorClass = 'text-blue-700';\n            backgroundClass = 'bg-blue-200';\n            break;\n        case 'warning':\n            colorClass = 'text-yellow-700';\n            backgroundClass = 'bg-yellow-200';\n            break;\n        default:\n            colorClass = 'text-blue-700';\n            backgroundClass = 'bg-blue-200';\n    }\n\n    if (!message.includes(\"nn\")) {\n        statusDiv.innerHTML += `\n            <p class=\"font-bold ${colorClass} ${backgroundClass} px-4 py-2 rounded-lg shadow-md\">\n                ${message}\n            </p>`;\n    }\n}\n\nexport function updateStatusMessage(message: string, type: string = 'info'): void {\n    let colorClass;\n    switch (type) {\n        case 'error':\n            colorClass = 'text-red-700';\n            break;\n        case 'success':\n            colorClass = 'text-white';\n            break;\n        case 'warning':\n            colorClass = 'text-yellow-700';\n            break;\n        case 'info':\n            colorClass = 'text-white';\n            break;\n        default:\n            colorClass = 'text-blue-700';\n    }\n\n    if (!message.includes(\"nn\")) {\n        statusMessage.innerText = message;\n        statusMessage.className = `font-bold ${colorClass}`;\n    }\n}\n\n/**\n * Evidenzia le immagini infette modificandone il bordo.\n *\n * @param fileNameInfected - Il nome del file infetto.\n */\nexport function highlightInfectedImages(fileNameInfected: string): void {\n    // Verifica che fileNameInfected sia una stringa\n    if (typeof fileNameInfected !== 'string') {\n        console.error('fileNameInfected deve essere una stringa');\n        return;\n    }\n\n    const infectedImage = document.getElementById(`file-${fileNameInfected}`);\n\n    if (infectedImage) {\n        const imgElement = infectedImage.querySelector('img');\n\n        // Verifica che imgElement sia un elemento immagine\n        if (imgElement instanceof HTMLImageElement) {\n            imgElement.style.border = '3px solid red';\n        } else {\n            console.error('Elemento immagine non trovato');\n        }\n    } else {\n        console.error(`Immagine non trovata per il file: ${fileNameInfected}`);\n    }\n}\n\n/**\n * Funzione per rimuovere un file specifico.\n *\n * @param fileName - Il nome del file da eliminare\n */\nexport async function removeFile(fileName: string): Promise<void> {\n    if (fileName) {\n        try {\n            // deleteTemporaryFileDO() è una funzione che elimina il file temporaneo dal disco esterno\n            // Questa funzione è commentata perché il file temporaneo sul disco esterno viene creato solo se è gestita la presignedURL\n            // in questa versione dell'applicazione non è gestita la presignedURL, quindi non viene creato il file temporaneo sul disco esterno\n            // await deleteTemporaryFileDO(fileName);\n\n            const fileIndex = Array.from(files).findIndex((file: File) => file.name === fileName);\n\n            if (fileIndex !== -1) {\n                const filesArray = Array.from(files);\n                filesArray.splice(fileIndex, 1);\n                if (window.envMode === 'local') {\n                    console.log('file rimanenti:', files);\n                }\n            }\n\n            removeImg(fileName);\n\n            if (window.envMode === 'local') {\n                console.log('file presenti DOPO della rimozione:', files);\n            }\n\n        } catch (error) {\n            if (window.envMode === 'local') {\n                console.error('Error deleting temporary file:', error);\n            }\n\n            throw new Error(window.deleteFileError);\n        }\n    } else {\n        if (window.envMode === 'local') {\n            console.log('File:', fileName);\n            console.log('File index not removed:', fileName);\n            console.log('File name not removed:', fileName);\n        }\n    }\n}\n\n/**\n * Funzione per rimuovere l'immagine dal DOM.\n * @param fileName - Il nome del file da eliminare\n */\nexport function removeImg(fileName: string): void {\n    const remove = document.getElementById(`file-${fileName}`);\n    if (window.envMode === 'local') {\n        console.log('file rimosso:', `file-${fileName}`);\n    }\n    if (remove && remove.parentNode) {\n        remove.parentNode.removeChild(remove);\n        if (files.length === 0) {\n            resetButtons();\n        }\n    }\n}\n\n","import { csrfToken, progressBar, progressText } from './domElements';\nimport { saveLocalTempFile } from './saveLocalTempFile';\nimport { deleteTemporaryFileExt, deleteTemporaryFileLocal } from './deleteTemporaryFiles';\nimport { updateStatusDiv } from './uploadUtils';\n\ndeclare const window: any;\n\ntype ScanFileResponse = {\n    response: Response;\n    data: any;\n};\n\n/**\n * Performs a virus scan on a file with a progress feedback simulation.\n *\n * @param formData - The form data containing the file to be scanned.\n * @returns A promise that resolves to the response and data from the server.\n * @throws An error if the request fails or the response is not ok.\n */\nexport async function scanFileWithProgress(formData: FormData): Promise<ScanFileResponse> {\n    if (window.envMode === 'local') {\n        console.log('Inside scanFileWithProgress');\n    }\n\n    let progress = 0;\n    const realScanDuration = 35000; // Simulated real scan duration of 35 seconds\n    const startTime = Date.now();\n\n    // Function to simulate progress up to 95%\n    function simulateProgress(): void {\n        const elapsedTime = Date.now() - startTime;\n        progress = Math.min(95, (elapsedTime / realScanDuration) * 100);\n        progressBar.style.width = `${progress}%`;\n        progressText.innerText = `${Math.round(progress)}%`;\n\n        if (progress >= 95) {\n            clearInterval(interval);\n        }\n    }\n\n    const interval = setInterval(simulateProgress, 100);\n\n    if (window.envMode === 'local') {\n        console.log('In scanFileWithProgress: formData:', formData); // Log the Content-Type to verify the type of response\n    }\n\n    try {\n        const response = await fetch('/scan-virus', {\n            method: 'POST',\n            headers: {\n                'X-CSRF-TOKEN': csrfToken,\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n\n        clearInterval(interval);\n\n        if (response.ok) {\n            const finalProgressInterval = setInterval(() => {\n                progress += 0.5;\n                progressBar.style.width = `${progress}%`;\n                progressText.innerText = `${Math.round(progress)}%`;\n\n                if (progress >= 100) {\n                    clearInterval(finalProgressInterval);\n                }\n            }, 50);\n\n            const data = await response.json();\n\n            if (data) {\n                return { response, data };\n            } else {\n                throw new Error('The JSON response is incorrect');\n            }\n        } else {\n            const data = await response.json();\n            return { response, data };\n        }\n    } catch (error: any) {\n        clearInterval(interval);\n        // throw new Error(`Error during file scan: ${error.message}`);\n        throw error;\n    }\n}\n\n/**\n * Handles the antivirus scan for the given file, saving it temporarily before scanning.\n *\n * @param formData - The form data containing the file to be scanned.\n * @returns A promise that resolves to a boolean indicating if the file is infected.\n * @throws An error if the request fails or the response is not ok.\n */\nexport async function handleVirusScan(formData: FormData): Promise<boolean> {\n    await saveLocalTempFile(formData);\n\n    // Scan the file and manage the progress bar\n    const { response, data } = await scanFileWithProgress(formData);\n\n    await deleteTemporaryFileLocal(formData.get('file') as File);\n\n    if (window.envMode === 'local') {\n        console.log(`response: ${response}`);\n        console.log(`data: ${JSON.stringify(data)}`);\n    }\n\n    if (!response.ok) {\n        // The file is infected\n        if (response.status === 422) {\n            updateStatusDiv(data.userMessage, 'error');\n            return true; // Virus found\n        }\n\n        // Throw an error if the response is not OK, with all the data from the response\n        throw data;\n    }\n\n    // File is not infected\n    return false;\n}\n","/**\n * Function to display an emoji based on the type provided.\n * This function dynamically creates a div element containing an image that represents a specific state.\n * The image source is first attempted to load from a CDN; if it fails, a fallback URL is used.\n * If the image takes longer than 5 seconds to load, a text \"OK\" is displayed instead of the image.\n * The function handles three types of states: success, someError, and completeFailure.\n *\n * @param {string} type - The type of emoji to display. It can be \"success\", \"someError\", or \"completeFailure\".\n * @throws Will throw an error if the type provided is not valid.\n */\nexport async function showEmoji(type: string): Promise<void> {\n    const div: HTMLDivElement = document.createElement('div');\n    const statusDiv: HTMLElement = document.getElementById('status') as HTMLElement;\n    div.classList.add('relative', 'group');\n\n    let emojyPng: string = '';\n    let fallbackUrl: string = '';\n    let altType: string = '';\n    let result: string = '';\n\n    if (type === \"success\") {\n        altType = (window as any).emogyHappy;\n        result = \"OK\";\n        emojyPng = \"https://cdn.nftflorence.com/assets/images/icons/GirlHappy.png\";\n        fallbackUrl = \"https://frangettediskspace.fra1.digitaloceanspaces.com/assets/images/icons/GirlHappy.png\";\n    } else if (type === \"someError\") {\n        altType = (window as any).emogySad;\n        result = window.someError;\n        emojyPng = \"https://cdn.nftflorence.com/assets/images/icons/GirlDisp.png\";\n        fallbackUrl = \"https://frangettediskspace.fra1.digitaloceanspaces.com/assets/images/icons/GirlDisp.png\";\n    } else if (type === \"completeFailure\") {\n        altType = (window as any).emogyAngry;\n        result = window.completeFailure;\n        emojyPng = \"https://cdn.nftflorence.com/assets/images/icons/GirlSad.png\";\n        fallbackUrl = \"https://frangettediskspace.fra1.digitaloceanspaces.com/assets/images/icons/GirlSad.png\";\n    } else {\n        throw new Error('Tipo non valido');\n    }\n\n    const timeoutId: number = window.setTimeout(() => {\n        div.innerHTML = `\n            <div class=\"flex items-center justify-center mt-4\">\n                <span class=\"font-bold text-4xl\">${result}</span>\n            </div>\n        `;\n        statusDiv.appendChild(div);\n    }, 3000);\n\n    try {\n        const response: Response = await fetch(emojyPng, { method: 'HEAD' });\n        if (!response.ok) {\n            emojyPng = fallbackUrl;\n        }\n    } catch (error) {\n        emojyPng = fallbackUrl;\n    }\n\n    div.innerHTML = `\n        <div class=\"flex items-center justify-center mt-4\">\n            <img src=\"${emojyPng}\"\n            alt=\"${altType}\"\n            id=\"emojy\"\n            title=\"${altType}\"\n            class=\"w-40 h-40 object-cover rounded-full shadow-md transition-all duration-300 group-hover:scale-105 z-0\">\n        </div>\n    `;\n\n    statusDiv.appendChild(div);\n    clearTimeout(timeoutId);\n}\n","export class BaseUploadHandler {\n    protected csrfToken: string;\n\n    constructor() {\n        const tokenElement = document.querySelector('meta[name=\"csrf-token\"]');\n        if (!tokenElement) throw new Error(\"CSRF token non trovato nel DOM\");\n        this.csrfToken = tokenElement.getAttribute(\"content\") || \"\";\n    }\n\n    /**\n     * Metodo generico di upload, da usare o sovrascrivere negli handler specifici.\n     * @param endpoint - L'URL dell'endpoint su cui effettuare l'upload.\n     * @param formData - Il FormData contenente il file e altri metadati.\n     * @returns Un oggetto contenente l'esito dell'upload, con `error`, `response` e `success`.\n     */\n    protected async performUpload(endpoint: string, formData: FormData): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        let errorData: UploadError | null = null; // Tipizziamo come UploadError | null\n        let success: boolean = true;\n\n        console.log('dentro performUpload. Endpoint:', endpoint);\n\n        try {\n            const response: Response = await fetch(endpoint, {\n                method: \"POST\",\n                headers: {\n                    \"X-CSRF-TOKEN\": this.csrfToken,\n                    \"Accept\": \"application/json\",\n                },\n                body: formData,\n            });\n\n            if (!response.ok) {\n                const contentType = response.headers.get(\"content-type\");\n\n                if (contentType && contentType.includes(\"application/json\")) {\n                    errorData = await response.json(); // Il server ha risposto con JSON\n                } else {\n                    const rawErrorData = await response.text(); // Il server ha risposto con HTML/testo\n                    errorData = {\n                        message: \"Il server ha restituito una risposta non valida.\",\n                        details: rawErrorData,\n                        state: \"unknown\",\n                        errorCode: \"unexpected_response\",\n                        blocking: \"blocking\",\n                    };\n                }\n\n                success = false;\n            }\n\n            return { error: errorData, response, success }; // Usiamo 'error' nel return\n        } catch (error) {\n            // Gestiamo errori di rete o fetch\n            errorData = {\n                message: \"Errore durante la richiesta di upload\",\n                details: error instanceof Error ? error.message : String(error),\n                state: \"network\",\n                errorCode: \"fetch_error\",\n                blocking: \"blocking\",\n            };\n            return { error: errorData, response: false, success: false };\n        }\n    }\n\n    /**\n     * Metodo astratto che deve essere implementato dagli handler specifici.\n     * @param file - Il file da caricare.\n     */\n    async handleUpload(file: File): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        // Versione temporanea per test\n        const formData = new FormData();\n        formData.append('file', file);\n        return this.performUpload('/uploading-files', formData);\n    }\n}\n","import { BaseUploadHandler } from \"./BaseUploadHandler\";\n\nexport class EGIUploadHandler extends BaseUploadHandler {\n    private maxAttempts: number = 3;\n\n    constructor() {\n        super();\n    }\n\n    async handleUpload(file: File): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"_token\", this.csrfToken);\n        formData.append(\"uploadType\", \"egi\");\n\n        let attempt = 0;\n        let error: UploadError | null = null; // Tipizziamo error come UploadError | null\n        let response: Response | boolean = false;\n        let success = false;\n\n        while (attempt < this.maxAttempts && !success) {\n            attempt++;\n            ({ error, response, success } = await this.performUpload(\"/upload/egi\", formData));\n\n            if (success) {\n                console.log(`Tentativo ${attempt} riuscito: ${file.name}`);\n                return { error, response, success };\n            } else {\n                console.warn(`Tentativo ${attempt} fallito: ${error?.message || \"Errore sconosciuto\"}`);\n            }\n\n            if (!success && attempt < this.maxAttempts) {\n                console.log(`Riprovo il tentativo ${attempt + 1}...`);\n            }\n        }\n\n        return { error, response, success };\n    }\n}\n","import { BaseUploadHandler } from \"./BaseUploadHandler\";\n\nexport class EPPUploadHandler extends BaseUploadHandler {\n    async handleUpload(file: File): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        const formData = new FormData();\n\n        // 🔹 Passaggio 1: Cifriamo il file prima dell'upload (simulato con una conversione Base64)\n        const encryptedFile = await this.encryptFile(file);\n        formData.append(\"file\", encryptedFile);\n        formData.append(\"_token\", this.csrfToken);\n        formData.append(\"uploadType\", \"epp\");\n\n        // 🔹 Passaggio 2: Eseguiamo l'upload con la logica personalizzata\n        return await this.performUpload(\"/upload/epp\", formData);\n    }\n\n    /**\n     * Sovrascriviamo `performUpload` per personalizzare il comportamento di upload.\n     */\n    protected async performUpload(endpoint: string, formData: FormData): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        let errorData: UploadError | null = null; // Tipizziamo come UploadError | null\n        let success: boolean = true;\n\n        try {\n            const response: Response = await fetch(endpoint, {\n                method: \"POST\",\n                headers: {\n                    \"X-CSRF-TOKEN\": this.csrfToken,\n                    \"Accept\": \"application/json\",\n                },\n                body: formData,\n            });\n\n            if (!response.ok) {\n                const contentType = response.headers.get(\"content-type\");\n                if (contentType && contentType.includes(\"application/json\")) {\n                    errorData = await response.json();\n                } else {\n                    errorData = {\n                        message: \"Il server ha restituito una risposta non valida.\",\n                        details: await response.text(),\n                        state: \"unknown\",\n                        errorCode: \"unexpected_response\",\n                        blocking: \"blocking\",\n                    };\n                }\n                success = false;\n            } else {\n                // 🔹 Verifica il token restituito dall'API per confermare l'upload\n                const result = await response.json();\n                if (!result.verificationToken || result.verificationToken !== \"VALID\") {\n                    success = false;\n                    errorData = {\n                        message: \"Errore: token di verifica non valido.\",\n                        errorCode: \"invalid_token\",\n                    };\n                }\n            }\n\n            // 🔹 Logga l'upload separatamente per gli EPP\n            this.logEPPUploadStatus(success, errorData);\n\n            return { error: errorData, response, success };\n        } catch (error) {\n            errorData = {\n                message: \"Errore durante la richiesta di upload\",\n                details: error instanceof Error ? error.message : String(error),\n                state: \"network\",\n                errorCode: \"fetch_error\",\n                blocking: \"blocking\",\n            };\n            return { error: errorData, response: false, success: false };\n        }\n    }\n\n    /**\n     * Metodo per cifrare il file (simulazione).\n     */\n    private async encryptFile(file: File): Promise<File> {\n        // Simuliamo una cifratura base64 per questo esempio\n        const arrayBuffer = await file.arrayBuffer();\n        const base64String = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n        const encryptedBlob = new Blob([base64String], { type: file.type });\n\n        return new File([encryptedBlob], file.name, { type: file.type });\n    }\n\n    /**\n     * Metodo per registrare il log degli upload EPP.\n     */\n    private logEPPUploadStatus(success: boolean, errorData: UploadError | null): void {\n        if (success) {\n            console.log(\"✔ Upload EPP completato con successo.\");\n        } else {\n            console.error(\"❌ Upload EPP fallito:\", errorData);\n        }\n    }\n}\n","import { BaseUploadHandler } from \"./BaseUploadHandler\";\n\nexport class UtilityUploadHandler extends BaseUploadHandler {\n    async handleUpload(file: File): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        const formData = new FormData();\n        formData.append(\"file\", file);\n        formData.append(\"_token\", this.csrfToken);\n        formData.append(\"uploadType\", \"utility\");\n\n        return await this.performUpload(\"/upload/utility\", formData);\n    }\n}\n","import { EGIUploadHandler } from \"./handlers/EGIUploadHandler\";\nimport { EPPUploadHandler } from \"./handlers/EPPUploadHandler\";\nimport { UtilityUploadHandler } from \"./handlers/UtilityUploadHandler\";\nimport { BaseUploadHandler } from \"./handlers/BaseUploadHandler\";\n\nexport class HubFileController {\n    private handlers: { [key: string]: BaseUploadHandler };\n\n    constructor() {\n        this.handlers = {\n            'egi': new EGIUploadHandler(),\n            'epp': new EPPUploadHandler(),\n            'utility': new UtilityUploadHandler(),\n            'default': new BaseUploadHandler(),\n        };\n    }\n\n    /**\n     * Gestisce l'upload di un file, indirizzandolo all'handler corretto.\n     * @param file - Il file da caricare\n     * @param uploadType - Il tipo di upload (egi, epp, utility, default)\n     * @returns Un oggetto con `error`, `response` e `success`\n     */\n     // Aggiorniamo il tipo di ritorno\n     async handleFileUpload(file: File, uploadType: string): Promise<{ error: UploadError | null; response: Response | boolean; success: boolean }> {\n        const handler = this.handlers[uploadType] || this.handlers['default'];\n\n        console.log(`Handling file upload with handler: ${handler.constructor.name}`);\n\n        try {\n            const { error, response, success } = await handler.handleUpload(file);\n            return { error, response, success };\n        } catch (error) {\n            const errorData: UploadError = {\n                message: \"Errore durante l'elaborazione dell'upload\",\n                details: error instanceof Error ? error.message : String(error),\n                state: \"handler\",\n                errorCode: \"handler_error\",\n                blocking: \"blocking\",\n            };\n            return { error: errorData, response: false, success: false };\n        }\n    }\n}\n","import { csrfToken, progressBar, progressText, scanProgressText, statusMessage, statusDiv, scanvirus, getFiles } from './domElements';\nimport { handleVirusScan } from './scanFile';\nimport { showEmoji } from './showEmoji';\nimport { HubFileController } from './hubFileController';\n\nimport {\n    disableButtons,\n    resetButtons,\n    removeEmojy,\n    handleImage,\n    enableButtons,\n    updateStatusDiv,\n    updateStatusMessage,\n    highlightInfectedImages,\n    removeFile,\n    removeImg\n} from './uploadUtils';\n\ndeclare const window: any;\n\ninterface FileUploadResult {\n    error: any; // Puoi creare un tipo più specifico se conosci la struttura degli errori\n    response: Response | false; // Il tipo `Response` per fetch API o `false` in caso di errore\n    success: boolean;\n}\n\n/**\n * Funzione per caricare un file lato server.\n * @param formData - I dati del form contenenti il file da caricare.\n * @returns Un oggetto contenente l'esito dell'upload, la risposta e gli eventuali errori.\n */\nexport async function fileForUpload(formData: FormData): Promise<FileUploadResult> {\n    let errorData: any = null;\n    let success: boolean = true;\n\n    if ((window as any).envMode === 'local') {\n        console.log('dentro fileForUpload');\n    }\n\n    if ((window as any).envMode === 'local') {\n        const file = formData.get('file') as File;\n        console.log('in fileForUpload: formData:', file?.name); // Log del Content-Type per verificare il tipo di risposta\n    }\n\n    try {\n        const response: Response = await fetch('/uploading-files', {\n            method: 'POST',\n            headers: {\n                'X-CSRF-TOKEN': (window as any).csrfToken,\n                'Accept': 'application/json',\n            },\n            body: formData\n        });\n\n        const contentType = response.headers.get('content-type');\n        if ((window as any).envMode === 'local') {\n            console.log('Content-Type:', contentType); // Log del Content-Type per verificare il tipo di risposta\n        }\n\n        if (!response.ok) {\n            if (contentType && contentType.includes('application/json')) {\n                errorData = await response.json(); // Ottieni la response dal server in formato JSON\n                success = false;\n            } else {\n                const rawErrorData = await response.text(); // Se non è JSON, ottieni il testo (potrebbe essere HTML)\n                errorData = {\n                    message: 'Il server ha restituito una risposta non valida o inaspettata.',\n                    details: rawErrorData, // Mantiene il contenuto HTML o testo come dettaglio\n                    state: 'unknown',\n                    errorCode: 'unexpected_response',\n                    blocking: 'blocking', // Considera questo un errore bloccante di default\n                };\n                success = false;\n            }\n\n            return { error: errorData, response, success };\n        }\n\n        return { error: false, response, success };\n\n    } catch (error) {\n        if ((window as any).envMode === 'local') {\n            console.error('Error in fileForUpload:', error);\n        }\n\n        return { error, response: false, success: false }; // Restituiamo l'errore come parte dell'oggetto\n    }\n}\n\n\n/**\n * Funzione che tenta l'upload di un file fino a un massimo di tentativi specificato.\n * Viene utilizzata per gestire il caricamento di un file verso il server,\n * con la possibilità di riprovare l'upload in caso di fallimento fino a\n * maxAttempts volte.\n *\n * @param formData - I dati del file da caricare, inclusi eventuali token CSRF e altri metadati.\n * @param maxAttempts - Il numero massimo di tentativi di upload. Default: 3.\n *\n * @returns Un oggetto contenente:\n *  - success: Indica se l'upload è stato completato con successo.\n *  - response: Contiene il risultato finale dell'upload o l'errore se tutti i tentativi falliscono.\n *\n * Note:\n * - Se l'upload fallisce, viene ripetuto fino a maxAttempts tentativi.\n * - La variabile 'result' è dichiarata all'esterno del ciclo per mantenere\n *   il suo valore finale al termine del ciclo, ed essere restituita correttamente alla funzione chiamante.\n */\nexport async function attemptFileUpload(formData: FormData, maxAttempts: number = 3): Promise<{ error: any; response: Response | boolean;  }> {\n    let attempt = 0;\n    let success = false;\n    let error: any = null;\n    let response: Response | boolean = false;\n\n    while (attempt < maxAttempts && !success) {\n        attempt++;\n\n        ({ error, response, success } = await fileForUpload(formData));\n\n        if (success) {\n            if (window.envMode === 'local') {\n                console.log(`Tentativo ${attempt} riuscito.`);\n            }\n            return { error, response };\n        } else {\n            if (window.envMode === 'local') {\n                console.warn(`Tentativo ${attempt} fallito: ${error.message}`);\n            }\n        }\n\n        if (!success && attempt < maxAttempts) {\n            if (window.envMode === 'local') {\n                console.log(`Riprovo il tentativo ${attempt + 1}...`);\n            }\n        }\n    }\n\n    return { error, response };\n}\n\n\n/**\n * Funzione che gestisce l'upload e la scansione dei file.\n */\nexport async function handleUpload(): Promise<void> {\n    const files = getFiles() || [];\n\n    if (window.envMode === 'local') {\n        console.log('📤 Uploading files:', files.length);\n    }\n\n    if (files.length === 0) {\n        console.warn('⚠️ Nessun file selezionato.');\n        return;\n    }\n\n    disableButtons();\n    statusMessage.innerText = window.startingSaving + '...';\n\n    let incremento = 100 / files.length;\n    let flagUploadOk = true;\n    let iterFailed = 0;\n    let someInfectedFiles = 0;\n    let index = 0;\n    let userMessage = \"\";\n\n    for (const file of files) {\n        const formData = new FormData();\n        formData.append('file', file);\n        formData.append('_token', csrfToken);\n        formData.append('index', index.toString());\n\n        const isLastFile = index === files.length - 1;\n        formData.append('finished', isLastFile ? 'true' : 'false');\n\n        if (isLastFile) {\n            formData.append('iterFailed', iterFailed.toString());\n        }\n\n        try {\n            if (window.envMode === 'local') {\n                console.log(`📂 Uploading file: ${file.name}`);\n            }\n\n            scanProgressText.innerText = '';\n\n            // 🔹 Se la scansione virus è attiva\n            if (scanvirus.checked) {\n                updateStatusMessage(window.startingScan + '...', 'info');\n\n                formData.append('someInfectedFiles', someInfectedFiles.toString());\n                formData.append('fileName', file.name);\n\n                if (await handleVirusScan(formData)) {\n                    flagUploadOk = false;\n                    iterFailed++;\n                    someInfectedFiles++;\n                    highlightInfectedImages(file.name);\n                    resetProgressBar();\n                    continue;\n                }\n            }\n\n            // Determina il tipo di upload dal contesto (URL)\n            const uploadType = determineUploadType(getUploadContext());\n\n            console.log(`📌 Smistamento su: ${uploadType}`);\n\n            // 🔹 Creiamo un'istanza dell'hub per la gestione degli upload\n            const hubFileController = new HubFileController();\n\n            const { error, response, success } = await hubFileController.handleFileUpload(file, uploadType);\n\n            if (!success) {\n                if (error?.details) {\n                    console.error('🚨 Errore non JSON:', error.details);\n                    userMessage = error.userMessage || \"Errore sconosciuto\";\n                    flagUploadOk = false;\n                    iterFailed++;\n                    updateStatusDiv(userMessage, 'error');\n                    if (error.blocking === 'blocking') break;\n                } else {\n                    console.error('🚨 Errore durante l\\'upload:', error);\n                    userMessage = error?.userMessage || \"Errore non specificato\";\n                    flagUploadOk = false;\n                    iterFailed++;\n                    updateStatusDiv(userMessage, 'error');\n                }\n            } else {\n                if (window.envMode === 'local') {\n                    console.log(`✅ Upload riuscito: ${file.name}`);\n                }\n\n                removeImg(file.name);\n\n                if (response instanceof Response) {\n                    const resultResponse = await response.json();\n                    updateStatusDiv(resultResponse.userMessage || updateFileSavedMessage(file.name), 'success');\n                    updateProgressBar(index, incremento);\n                }\n            }\n\n        } catch (error) {\n            flagUploadOk = false;\n\n            if (window.envMode === 'local') {\n                console.error(`❌ Catch in handleUpload: ${error}`);\n            }\n\n            // Tipizziamo l'errore come UploadError o generico\n            const uploadError: UploadError = error instanceof Error ? {\n                message: error.message,\n                details: error.stack,\n                state: \"unknown\",\n                errorCode: \"unexpected_error\",\n                blocking: \"blocking\"\n            } : error;\n\n            if (uploadError.blocking === 'blocking') {\n                updateStatusMessage(uploadError.userMessage || \"Errore critico durante l'upload\", 'error');\n                iterFailed = files.length;\n                break;\n            } else {\n                userMessage = uploadError.userMessage || \"Errore durante l'upload\";\n                updateStatusDiv(`${userMessage} ${window.of} ${file.name}`, 'error');\n                updateStatusMessage(userMessage, 'error');\n                iterFailed++;\n                resetProgressBar();\n            }\n        }\n        index++;\n    }\n\n    finalizeUpload(flagUploadOk, iterFailed);\n}\n\n/**\n * Funzione per determinare il tipo di upload in base al contesto.\n * @param contextType - Il tipo di upload determinato dal contesto (es. endpoint o parametro).\n * @returns Il tipo di upload ('egi', 'epp', 'utility', ecc.).\n */\nfunction determineUploadType(contextType: string): string {\n    const validTypes = ['egi', 'epp', 'utility'];\n    return validTypes.includes(contextType) ? contextType : 'default';\n}\n\n/**\n * Funzione per determinare il contesto di upload dall'URL corrente.\n * @returns Il tipo di contesto ('egi', 'epp', 'utility', ecc.).\n */\nfunction getUploadContext(): string {\n    const currentPath = window.location.pathname;\n    if (currentPath.includes('/upload/egi')) return 'egi';\n    if (currentPath.includes('/upload/epp')) return 'epp';\n    if (currentPath.includes('/upload/utility')) return 'utility';\n    return 'default'; // Fallback\n}\n\n/**\n * Aggiorna la barra di progresso.\n * @param index - Indice del file attualmente in upload\n * @param incremento - Valore da aggiungere alla barra di progresso\n */\nfunction updateProgressBar(index: number, incremento: number): void {\n    progressBar.style.width = `${(index + 1) * incremento}%`;\n    progressText.innerText = `${Math.round((index + 1) * incremento)}%`;\n}\n\n/**\n * Resetta la barra di progresso in caso di errore.\n */\nfunction resetProgressBar(): void {\n    progressBar.style.width = \"0\";\n    progressText.innerText = \"\";\n}\n\n/**\n * Funzione per finalizzare l'upload e mostrare i risultati.\n *\n * @param flagUploadOk - Booleano che indica se l'upload complessivo è riuscito.\n * @param iterFailed - Numero di tentativi di upload falliti.\n */\nexport function finalizeUpload(flagUploadOk: boolean, iterFailed: number): void {\n    resetButtons(); // Riabilita i pulsanti alla fine dell'upload\n\n    const files = getFiles() || [];\n\n    if (flagUploadOk && iterFailed === 0) {\n        showEmoji('success');\n    } else if (!flagUploadOk && iterFailed > 0 && iterFailed < files.length) {\n        showEmoji('someError');\n    } else if (!flagUploadOk && iterFailed === files.length) {\n        showEmoji('completeFailure');\n        updateStatusMessage(window.completeFailure, 'error');\n    }\n}\n\n\n/**\n * Funzione per aggiornare il messaggio di salvataggio del file.\n *\n * @param nomeFile - Il nome del file salvato correttamente.\n * @returns Il messaggio aggiornato con il nome del file salvato.\n */\nexport function updateFileSavedMessage(nomeFile: string): string {\n    const messageTemplate = window.fileSavedSuccessfullyTemplate;\n    return messageTemplate.replace(':fileCaricato', nomeFile);\n}\n\n","// resources/ts/validation.ts\nif (window.envMode === 'local') {\n    console.log('Dentro resources/ts/validation.ts');\n}\n\nexport interface ValidationResult {\n    isValid: boolean;\n    message?: string;\n}\n\nimport Swal from 'sweetalert2';\n\nexport function validateFile(file: File): ValidationResult {\n    const extension = file.name.split('.').pop()?.toLowerCase();\n\n    if (!window.allowedExtensions.includes(extension!)) {\n        const allowedExtensionsList = window.allowedExtensions.join(', ');\n        const errorMessage = window.allowedExtensionsMessage\n            .replace(':extension', extension!)\n            .replace(':extensions', allowedExtensionsList);\n\n        // Mostra il messaggio di errore all'utente usando Swal\n        Swal.fire({\n            title: window.titleExtensionNotAllowedMessage,\n            text: errorMessage,\n            icon: 'error',\n            confirmButtonText: 'OK'\n        });\n\n        return { isValid: false, message: errorMessage };\n    }\n\n    if (!window.allowedMimeTypes.includes(file.type)) {\n        const errorMessage = window.allowedMimeTypesMessage\n            .replace(':type', file.type)\n            .replace(':mimetypes', window.allowedMimeTypesListMessage);\n\n        // Mostra il messaggio di errore all'utente usando Swal\n        Swal.fire({\n            title: window.titleFileTypeNotAllowedMessage,\n            text: errorMessage,\n            icon: 'error',\n            confirmButtonText: 'OK'\n        });\n\n        return { isValid: false, message: errorMessage };\n    }\n\n    if (file.size > window.maxSize) {\n\n        const errorMessage = window.maxSizeMessage.replace(':size', (window.maxSize / 1024).toString());\n\n        // Mostra il messaggio di errore all'utente usando Swal\n        Swal.fire({\n            title: window.titleFileSizeExceedsMessage,\n            text: errorMessage,\n            icon: 'error',\n            confirmButtonText: 'OK'\n        });\n\n        return { isValid: false, message: errorMessage };\n    }\n\n    if (!validateFileName(file.name)) {\n        const errorMessage = window.invalidFileNameMessage.replace(':filename', file.name);\n\n        // Mostra il messaggio di errore all'utente usando Swal\n        Swal.fire({\n            title: window.titleInvalidFileNameMessage,\n            text: errorMessage,\n            icon: 'error',\n            confirmButtonText: 'OK'\n        });\n\n        return { isValid: false, message: errorMessage };\n    }\n\n    return { isValid: true };\n}\n\n\nexport function validateFileName(fileName: string): boolean {\n    const regex = /^[\\w\\-. ]+$/;\n    return regex.test(fileName);\n}\n","/**\n * Function to handle the UI updates related to file upload preparation.\n * This function handles tasks such as displaying status messages, updating progress bars, creating image previews,\n * and managing the visibility of delete buttons for each file. It does not perform the actual file upload.\n *\n * @param {FileList} files - List of files to be prepared for upload.\n * @returns {Promise<void>} - An asynchronous function that performs the UI updates for the file preparation.\n */\n\ninterface Window {\n    startingUpload: string;\n    loading: string;\n    uploadFiniscedText: string;\n    uploadAndScanText: string;\n    scanvirus: { checked: boolean };\n    envMode: string;\n}\n\nimport {\n    statusMessage,\n    statusDiv,\n    scanProgressText,\n    progressBar,\n    uploadBtn,\n    uploadFilebtn,\n    returnToCollectionBtn,\n    cancelUploadBtn,\n    scanvirusLabel,\n    scanvirus,\n    virusAdvise,\n    circleLoader,\n    circleContainer\n} from './domElements';\n\nimport {\n    disableButtons,\n    enableButtons,\n    resetButtons,\n    removeEmojy,\n    handleImage,\n    updateStatusDiv,\n    updateStatusMessage\n} from './uploadUtils';\n\nconst fileNames: string[] = [];\n\nexport async function prepareFilesForUploadUI(files: FileList): Promise<void> {\n\n    let incremento: number = 0;\n\n    // Update status messages and initialize UI components\n    statusMessage.innerText = window.startingUpload + '...';\n    statusDiv.innerHTML = '';\n    scanProgressText.innerText = '';\n\n    // Calculate the progress increment per file\n    incremento = 100 / files.length;\n    disableButtons();\n    removeEmojy();\n\n    // Iterate over each file in the FileList and handle its preparation process\n    for (let i = 0; i < files.length; i++) {\n        const file = files[i];\n        fileNames[i] = file.name;\n        progressBar.style.width = '0%';\n\n        try {\n            // Update the status message during the preparation process\n            statusMessage.innerText = window.loading + '...';\n\n            // Create an image preview\n            handleImage(i, { target: { result: URL.createObjectURL(file) } }, files);\n\n            // Make delete buttons visible for each file\n            for (let j = 0; j < files.length; j++) {\n                const fileName = files[j].name;\n                const deleteButton = document.getElementById(`button-${fileName}`) as HTMLElement | null;\n                if (deleteButton) {\n                    deleteButton.classList.remove('hidden');\n                }\n            }\n\n            // Enable buttons after the preparation process\n            enableButtons();\n            console.log('Preparation completed', window.uploadFiniscedText);\n\n            // Update the status message based on whether the virus scan is checked\n            if (scanvirus.checked) {\n                statusMessage.innerText = window.uploadAndScanText;\n            } else {\n                statusMessage.innerText = window.uploadFiniscedText;\n            }\n\n        } catch (result: any) {\n            // Handle errors during the preparation process\n            let userMessage: string = result.userMessage;\n\n            if (window.envMode === 'local') {\n                console.log('getPresignedUrl error catch');\n                console.log('userMessage', userMessage);\n            }\n            updateStatusDiv(`${file.name}: ${userMessage}`, 'error');\n            updateStatusMessage(userMessage, 'error');\n        }\n    }\n}\n","// Real-time listener for handling upload notifications via Laravel Echo.\n\n// import Echo from 'laravel-echo';\nimport { updateStatusMessage } from './uploadUtils';\n\ndeclare const window: any;\n\ntype UploadEvent = {\n  state: string;\n  message: string;\n  user_id: number;\n  progress: number;\n};\n\n/**\n * Sets up a real-time listener using Laravel Echo to handle different states of the file upload and processing.\n * Updates UI elements based on the type of event received.\n */\nexport function setupRealTimeUploadListener(): void {\n    window.Echo.private('upload')\n    .listen('FileProcessingUpload', (e: UploadEvent) => {\n      switch (e.state) {\n        case 'processSingleFileCompleted':\n          logEvent(e, 'success');\n          updateStatusMessage(e.message, 'success');\n          clearInterval(window.scanInterval);\n          break;\n        case 'allFileSaved':\n          logEvent(e, 'success');\n          updateStatusMessage(e.message, 'success');\n          clearInterval(window.scanInterval);\n          break;\n        case 'uploadFailed':\n          logEvent(e, 'error');\n          updateStatusMessage(e.message, 'error');\n          clearInterval(window.scanInterval);\n          break;\n        case 'finishedWithSameError':\n          logEvent(e, 'warning');\n          updateStatusMessage(e.message, 'warning');\n          clearInterval(window.scanInterval);\n          document.getElementById('circle-container')!.style.display = 'none';\n          break;\n        case 'allFileScannedNotInfected':\n          logEvent(e, 'success');\n          updateStatusMessage(e.message, 'success');\n          document.getElementById('circle-container')!.style.display = 'none';\n          break;\n        case 'allFileScannedSomeInfected':\n          logEvent(e, 'warning');\n          updateStatusMessage(e.message, 'warning');\n          document.getElementById('circle-container')!.style.display = 'none';\n          break;\n        case 'scanndeSameError':\n          logEvent(e, 'error');\n          updateStatusMessage(e.message, 'error');\n          document.getElementById('circle-container')!.style.display = 'none';\n          break;\n        case 'loadingProceedWithSaving':\n          logEvent(e, 'error');\n          updateStatusMessage(e.message, 'error');\n          break;\n        case 'virusScan':\n          logEvent(e, 'info');\n          document.getElementById('circle-container')!.style.display = 'block';\n          document.getElementById('status-message')!.innerText = e.message;\n          break;\n        case 'endVirusScan':\n          logEvent(e, 'info');\n          document.getElementById('circle-container')!.style.display = 'none';\n          document.getElementById('status-message')!.innerText = e.message;\n          break;\n        case 'validation':\n          logEvent(e, 'info');\n          updateStatusMessage(e.message, 'info');\n          break;\n        case 'tempFileDeleted':\n          logEvent(e, 'info');\n          break;\n        case 'error':\n          logEvent(e, 'error');\n          break;\n        case 'infected':\n          logEvent(e, 'error');\n          updateStatusMessage(e.message, 'error');\n          clearInterval(window.scanInterval);\n          document.getElementById('circle-loader')!.style.background = `conic-gradient(#ff0000 100%, #ddd 0%)`;\n          document.getElementById('scan-progress-text')!.innerText = window.someInfectedFiles;\n          document.getElementById('circle-container')!.style.display = 'none';\n          break;\n        case 'info':\n          logEvent(e, 'info');\n          updateStatusMessage(e.message, 'info');\n          break;\n        default:\n          logEvent(e, 'info');\n          break;\n      }\n    });\n}\n\n/**\n * Logs events to the console if running in local environment mode.\n *\n * @param e The event object received from Laravel Echo.\n * @param type The type of the log (e.g., success, error, info).\n */\nfunction logEvent(e: UploadEvent, type: string): void {\n  if (window.envMode === 'local') {\n    console.log(`Event Type: ${type}`, e);\n    console.log(`Message: ${e.message}`);\n  }\n}\n","import { handleUpload } from './uploading';\nimport { validateFile } from './validation';\nimport { showEmoji } from './showEmoji';\nimport { prepareFilesForUploadUI } from './prepareFilesForUploadUI';\nimport {\n    scanProgressText,\n    progressBar,\n    progressText,\n    getFiles,\n    scanvirusLabel,\n    scanvirus,\n    virusAdvise,\n    statusDiv,\n    statusMessage,\n} from './domElements';\n\nimport {\n    resetButtons,\n    handleImage,\n    removeFile,\n    removeImg\n} from './uploadUtils';\n\nimport { setupRealTimeUploadListener } from './realTimeUploadListener';\n\ndeclare const window: any;\n\n/**\n * @param files - Lista di file da validare\n * @returns Restituisce true se tutti i file sono validi, altrimenti false\n */\nfunction validation(files: FileList | null): boolean {\n    if (!files) {\n        return false;\n    }\n\n    for (let i = 0; i < files.length; i++) {\n        const validationResult = validateFile(files[i]);\n        if (!validationResult.isValid) {\n            console.error(`File ${files[i].name} did not pass the validation checks: ${validationResult.message}`);\n            return false; // Se il file non è valido, esce dalla funzione\n        }\n    }\n    return true; // Se tutti i file sono validi, restituisce true\n}\nconsole.log('Dentro file_upload_manager');\nconsole.time('handleUploadSetup');\ndocument.addEventListener('DOMContentLoaded', function () {\n\n    window.showEmoji = showEmoji;\n    window.handleImage = handleImage;\n    window.removeFile = removeFile;\n    window.handleFileSelect = handleFileSelect;\n    window.handleUpload = handleUpload;\n    window.handleDrop = handleDrop;\n    window.redirectToCollection = redirectToCollection;\n    window.resetButtons = resetButtons;\n    window.cancelUpload = cancelUpload;\n\n    console.log('allowedExtensions', window.allowedExtensions);\n    console.log('allowedMimeTypes', window.allowedMimeTypes);\n    console.log('envMode', window.envMode);\n\n    if (window.envMode === 'local') {\n\n        console.log('allowedExtensions', window.allowedExtensions);\n        console.log('allowedMimeTypes', window.allowedMimeTypes);\n        console.log('maxSize', window.maxSize);\n\n        console.log('Dentro file_upload_manager');\n    }\n\n    if (window.envMode === 'local') {\n        console.log('Send email:', window.sendEmail);\n    }\n\n    scanProgressText.innerText = \"\";\n\n    // Chiama Ascoltatore per la gestione delle notifiche in tempo reale\n    setupRealTimeUploadListener();\n\n    progressBar.style.width = \"0\";\n    progressText.innerText = \"\";\n\n    if (window.envMode === 'local') {\n        console.log(window.uploadFiniscedText);\n        console.log('allowedExtensionsMessage:', window.allowedExtensionsMessage);\n        console.log('allowedExtensionsListMessage:', window.allowedExtensionsListMessage);\n        console.log('allowedMimeTypesMessage:', window.allowedMimeTypesMessage);\n    }\n\n    // Gestione dell'attivazione della scansione antivirus\n    scanvirus.addEventListener('click', function() {\n        if (scanvirus.checked) {\n            scanvirusLabel.classList.remove('text-red-500');\n            scanvirusLabel.classList.add('text-green-500');\n            scanvirusLabel.innerText = window.enableVirusScanning;\n            virusAdvise.style.display = 'block';\n            virusAdvise.classList.add('text-red-500');\n            virusAdvise.innerText = window.virusScanAdvise;\n        } else {\n            scanvirusLabel.classList.remove('text-green-500');\n            scanvirusLabel.classList.add('text-red-500');\n            scanvirusLabel.innerText = window.disableVirusScanning;\n            virusAdvise.style.display = 'none';\n        }\n    });\n\n    // Funzione per la redirezione verso la collezione dopo l'upload\n    function redirectToCollection(): void {\n        // console.log('Redirecting to collection...', window.URLRedirectToCollection);\n        // alert(window.redirectToCollection);\n        window.location.href = window.URLRedirectToCollection;\n    }\n\n    // Funzione che gestisce la selezione dei file\n    async function handleFileSelect(event: Event): Promise<void> {\n\n        console.log('Handling file select...');\n\n\n        const files = getFiles();\n        if (validation(files)) {\n            await prepareFilesForUploadUI(files!);\n        }\n    }\n\n    // Funzione che gestisce il drag & drop dei file\n    async function handleDrop(event: DragEvent): Promise<void> {\n        event.preventDefault();\n        const files = event.dataTransfer?.files;\n        if (files && validation(files)) {\n            await prepareFilesForUploadUI(files);\n        }\n    }\n\n    // Funzione per annullare l'upload\n    async function cancelUpload(): Promise<void> {\n\n        let shouldBlockUnload = false;\n\n        const files = getFiles();\n        if (files) {\n            for (const file of files) {\n                if (file && file.name) {\n                    removeImg(file.name);\n                }\n            }\n        }\n\n        try {\n            const success = await deleteTemporaryFolder();\n            if (!success) {\n                shouldBlockUnload = true;\n            }\n        } catch (error) {\n            shouldBlockUnload = true;\n        }\n\n        resetButtons();\n        document.getElementById('collection')!.innerHTML = '';\n        progressBar.style.width = '0%';\n        progressText.innerText = '';\n        statusMessage.innerText = 'Upload Status: In attesa...';\n        statusDiv.innerHTML = '';\n    }\n\n    console.log('Adding event listeners...');\n    console.timeEnd('handleUploadSetup');\n\n});\n\nwindow.addEventListener('beforeunload', async function (e: BeforeUnloadEvent) {\n    let shouldBlockUnload = false;\n\n    try {\n        const success = await deleteTemporaryFolder();\n        if (!success) {\n            shouldBlockUnload = true;\n        }\n    } catch (error) {\n        shouldBlockUnload = true;\n    }\n\n    if (shouldBlockUnload) {\n        e.preventDefault();\n        e.returnValue = '';\n    }\n});\n\n// Funzione per eliminare la cartella temporanea sul server\nasync function deleteTemporaryFolder(): Promise<boolean> {\n    const csrfToken = (document.querySelector('meta[name=\"csrf-token\"]') as HTMLMetaElement).getAttribute('content');\n    try {\n        const response = await fetch('/delete-temporary-folder', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRF-TOKEN': csrfToken || ''\n            },\n            body: JSON.stringify({\n                folderName: window.temporaryFolder\n            })\n        });\n\n        if (!response.ok) {\n            throw new Error('Failed to delete temporary folder');\n        }\n\n        console.log('Temporary folder deleted successfully');\n        return true;\n    } catch (error) {\n        console.error('Error deleting temporary folder:', error);\n        return false;\n    }\n}\n\n\n"],"names":["statusMessage","statusDiv","scanProgressText","progressBar","progressText","uploadFilebtn","returnToCollectionBtn","scanvirusLabel","scanvirus","virusAdvise","uploadBtn","cancelUploadBtn","emojiElements","csrfMeta","csrfToken","collection","getFiles","saveLocalTempFile","formData","response","result","error","deleteTemporaryFileLocal","file","files","disableButtons","i","delFileBtn","enableButtons","resetButtons","removeEmojy","emoji","handleImage","index","event","div","updateStatusDiv","message","type","colorClass","backgroundClass","updateStatusMessage","highlightInfectedImages","fileNameInfected","infectedImage","imgElement","removeFile","fileName","fileIndex","removeImg","remove","scanFileWithProgress","progress","realScanDuration","startTime","simulateProgress","elapsedTime","interval","finalProgressInterval","data","handleVirusScan","showEmoji","emojyPng","fallbackUrl","altType","timeoutId","BaseUploadHandler","tokenElement","endpoint","errorData","success","contentType","EGIUploadHandler","attempt","EPPUploadHandler","encryptedFile","arrayBuffer","base64String","encryptedBlob","UtilityUploadHandler","HubFileController","uploadType","handler","handleUpload","incremento","flagUploadOk","iterFailed","someInfectedFiles","userMessage","isLastFile","resetProgressBar","determineUploadType","getUploadContext","hubFileController","resultResponse","updateFileSavedMessage","updateProgressBar","uploadError","finalizeUpload","contextType","currentPath","nomeFile","validateFile","extension","_a","allowedExtensionsList","errorMessage","Swal","validateFileName","prepareFilesForUploadUI","j","deleteButton","setupRealTimeUploadListener","logEvent","validation","validationResult","handleFileSelect","handleDrop","redirectToCollection","cancelUpload","shouldBlockUnload","deleteTemporaryFolder"],"mappings":"sDAEa,MAAAA,EAAgB,SAAS,eAAe,gBAAgB,EACxDC,EAAY,SAAS,eAAe,QAAQ,EAC5CC,EAAmB,SAAS,eAAe,oBAAoB,EAC/DC,EAAc,SAAS,eAAe,cAAc,EACpDC,EAAe,SAAS,eAAe,eAAe,EACtDC,EAAgB,SAAS,eAAe,YAAY,EACpDC,EAAwB,SAAS,eAAe,oBAAoB,EACpEC,EAAiB,SAAS,eAAe,iBAAiB,EAC1DC,EAAY,SAAS,eAAe,WAAW,EAC/CC,EAAc,SAAS,eAAe,cAAc,EACrC,SAAS,eAAe,eAAe,EACpC,SAAS,eAAe,kBAAkB,EAC5D,MAAAC,EAAY,SAAS,eAAe,WAAW,EAC/CC,EAAkB,SAAS,eAAe,cAAc,EACxDC,EAAgB,SAAS,iBAAiB,QAAQ,EACzDC,EAAW,SAAS,cAAc,yBAAyB,EACjE,GAAI,CAACA,EACK,MAAA,IAAI,MAAM,oCAAoC,EAE3C,MAAAC,EAAYD,EAAS,aAAa,SAAS,EAC3CE,EAAa,SAAS,eAAe,YAAY,EAGvD,SAASC,GAA4B,CACxC,OAAK,SAAS,eAAe,OAAO,EAG5B,SAAS,eAAe,OAAO,EAAuB,MAFnD,IAGf,CCfA,eAAsBC,EAAkBC,EAA4C,CAC5E,OAAO,UAAY,SACnB,QAAQ,IAAI,0BAA0B,EAGtC,GAAA,CACM,MAAAC,EAAW,MAAM,MAAM,eAAgB,CACzC,OAAQ,OACR,QAAS,CACL,eAAgBL,EAChB,OAAU,kBACd,EACA,KAAMI,CAAA,CACT,EAMG,GAJA,OAAO,UAAY,SACX,QAAA,IAAI,sCAAuCC,CAAQ,EAG3D,CAACA,EAAS,GAAI,CACR,MAAAC,EAAS,MAAMD,EAAS,KAAK,EAE/B,OAAO,UAAY,SACX,QAAA,IAAI,oCAAqCC,CAAM,EAG3D,MAAMC,EAAQ,KAAK,UAAUD,EAAO,KAAK,EACrC,MAAA,OAAO,UAAY,SACX,QAAA,IAAI,mCAAoCC,CAAK,EAGnD,IAAI,MAAMA,CAAK,CAAA,CAGlB,OAAAF,QAEFE,EAAY,CAEb,MAAA,OAAO,UAAY,SACX,QAAA,MAAM,8BAA+BA,CAAK,EAEhDA,CAAA,CAGd,CCEA,eAAsBC,EAAyBC,EAA+B,CACtE,OAAO,UAAY,SACX,QAAA,IAAI,kCAAmCA,CAAI,EAGjD,MAAAL,EAAW,IAAI,SACZA,EAAA,OAAO,OAAQK,CAAI,EACnBL,EAAA,OAAO,SAAUJ,CAAS,EAE/B,GAAA,CACM,MAAAK,EAAW,MAAM,MAAM,+BAAgC,CACzD,OAAQ,OACR,QAAS,CACL,eAAgBL,EAChB,OAAU,kBACd,EACA,KAAMI,CAAA,CACT,EAOG,GALA,OAAO,UAAY,UACX,QAAA,KAAK,YAAaC,CAAQ,EAC1B,QAAA,KAAK,mBAAoBA,EAAS,MAAM,GAGhD,CAACA,EAAS,GAAI,CACR,MAAAC,EAAS,MAAMD,EAAS,KAAK,EAE/B,MAAA,OAAO,UAAY,SACX,QAAA,IAAI,2CAA4CC,CAAM,EAG5DA,CAAA,CAGH,OAAAD,QAEFE,EAAY,CAEb,MAAA,OAAO,UAAY,SACX,QAAA,MAAM,qCAAsCA,CAAK,EAGvDA,CAAA,CAEd,CCtFA,MAAMG,EAAQR,EAAS,GAAK,CAAC,EAGtB,SAASS,GAAuB,CAEnC,QAASC,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CAC7B,MAAAC,EAAa,SAAS,eAAe,UAAUH,EAAME,CAAC,EAAE,IAAI,EAAE,EAChEC,IACAA,EAAW,MAAM,QAAU,OAC/B,CAGJtB,EAAc,MAAM,QAAU,OAC9BK,EAAU,MAAM,QAAU,OAC1BJ,EAAsB,MAAM,QAAU,OACtCK,EAAgB,MAAM,QAAU,MACpC,CAEO,SAASiB,GAAsB,CAElC,QAASF,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CAC7B,MAAAC,EAAa,SAAS,eAAe,UAAUH,EAAME,CAAC,EAAE,IAAI,EAAE,EAChEC,IACAA,EAAW,MAAM,QAAU,eAC/B,CAGYhB,EAAA,UAAU,OAAO,aAAc,oBAAoB,EACnED,EAAU,MAAM,QAAU,eAC1BJ,EAAsB,MAAM,QAAU,eACtCK,EAAgB,MAAM,QAAU,eAChCD,EAAU,SAAW,GACXA,EAAA,UAAU,OAAO,aAAc,oBAAoB,EAC7DC,EAAgB,SAAW,EAC/B,CAEO,SAASkB,GAAqB,CAEjC,QAASH,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CAC7B,MAAAC,EAAa,SAAS,eAAe,UAAUH,EAAME,CAAC,EAAE,IAAI,EAAE,EAChEC,IACAA,EAAW,MAAM,QAAU,eAC/B,CAGJtB,EAAc,MAAM,QAAU,eAC9BK,EAAU,MAAM,QAAU,eAChBA,EAAA,UAAU,IAAI,aAAc,oBAAoB,EAC1DA,EAAU,SAAW,GACrBC,EAAgB,MAAM,QAAU,eAChCA,EAAgB,SAAW,GACXA,EAAA,UAAU,IAAI,aAAc,oBAAoB,EAChEL,EAAsB,MAAM,QAAU,eAC1BwB,EAAA,CAChB,CAEO,SAASA,GAAoB,CAClBlB,EAAA,QAASmB,GAAU,CAC7BA,EAAM,OAAO,CAAA,CAChB,CACL,CAEgB,SAAAC,EAAYC,EAAeC,EAAuCV,EAAuB,CAC/F,MAAAW,EAAM,SAAS,cAAc,KAAK,EACpCA,EAAA,UAAU,IAAI,WAAY,OAAO,EACpCA,EAAY,MAAQF,EAErBE,EAAI,UAAY;AAAA,+CAC2BX,EAAMS,CAAK,EAAE,IAAI;AAAA,oBAC5CC,EAAM,OAAO,MAAM;AAAA,2CACIV,EAAMS,CAAK,EAAE,IAAI,0BAA0BT,EAAMS,CAAK,EAAE,IAAI;AAAA,cACzF,OAAO,MAAM;AAAA;AAAA;AAAA,iDAGsBT,EAAMS,CAAK,EAAE,IAAI;AAAA;AAAA,YAG9DlB,EAAW,YAAYoB,CAAG,EAEtB,OAAO,UAAY,SACnB,QAAQ,IAAI,cAAeX,EAAMS,CAAK,EAAE,IAAI,CAEpD,CACgB,SAAAG,EAAgBC,EAAiBC,EAAe,OAAc,CAC1E,IAAIC,EAAa,GACbC,EAAkB,GAEtB,OAAQF,EAAM,CACV,IAAK,QACYC,EAAA,eACKC,EAAA,aAClB,MACJ,IAAK,UACYD,EAAA,iBACKC,EAAA,eAClB,MACJ,IAAK,OACYD,EAAA,gBACKC,EAAA,cAClB,MACJ,IAAK,UACYD,EAAA,kBACKC,EAAA,gBAClB,MACJ,QACiBD,EAAA,gBACKC,EAAA,aAAA,CAGrBH,EAAQ,SAAS,IAAI,IACtBpC,EAAU,WAAa;AAAA,kCACGsC,CAAU,IAAIC,CAAe;AAAA,kBAC7CH,CAAO;AAAA,kBAGzB,CAEgB,SAAAI,EAAoBJ,EAAiBC,EAAe,OAAc,CAC1E,IAAAC,EACJ,OAAQD,EAAM,CACV,IAAK,QACYC,EAAA,eACb,MACJ,IAAK,UACYA,EAAA,aACb,MACJ,IAAK,UACYA,EAAA,kBACb,MACJ,IAAK,OACYA,EAAA,aACb,MACJ,QACiBA,EAAA,eAAA,CAGhBF,EAAQ,SAAS,IAAI,IACtBrC,EAAc,UAAYqC,EACZrC,EAAA,UAAY,aAAauC,CAAU,GAEzD,CAOO,SAASG,EAAwBC,EAAgC,CAEhE,GAAA,OAAOA,GAAqB,SAAU,CACtC,QAAQ,MAAM,0CAA0C,EACxD,MAAA,CAGJ,MAAMC,EAAgB,SAAS,eAAe,QAAQD,CAAgB,EAAE,EAExE,GAAIC,EAAe,CACT,MAAAC,EAAaD,EAAc,cAAc,KAAK,EAGhDC,aAAsB,iBACtBA,EAAW,MAAM,OAAS,gBAE1B,QAAQ,MAAM,+BAA+B,CACjD,MAEQ,QAAA,MAAM,qCAAqCF,CAAgB,EAAE,CAE7E,CAOA,eAAsBG,EAAWC,EAAiC,CAC9D,GAAIA,EACI,GAAA,CAMM,MAAAC,EAAY,MAAM,KAAKxB,CAAK,EAAE,UAAWD,GAAeA,EAAK,OAASwB,CAAQ,EAEhFC,IAAc,KACK,MAAM,KAAKxB,CAAK,EACxB,OAAOwB,EAAW,CAAC,EAC1B,OAAO,UAAY,SACX,QAAA,IAAI,kBAAmBxB,CAAK,GAI5CyB,EAAUF,CAAQ,EAEd,OAAO,UAAY,SACX,QAAA,IAAI,sCAAuCvB,CAAK,QAGvDH,EAAO,CACR,MAAA,OAAO,UAAY,SACX,QAAA,MAAM,iCAAkCA,CAAK,EAGnD,IAAI,MAAM,OAAO,eAAe,CAAA,MAGtC,OAAO,UAAY,UACX,QAAA,IAAI,QAAS0B,CAAQ,EACrB,QAAA,IAAI,0BAA2BA,CAAQ,EACvC,QAAA,IAAI,yBAA0BA,CAAQ,EAG1D,CAMO,SAASE,EAAUF,EAAwB,CAC9C,MAAMG,EAAS,SAAS,eAAe,QAAQH,CAAQ,EAAE,EACrD,OAAO,UAAY,SACnB,QAAQ,IAAI,gBAAiB,QAAQA,CAAQ,EAAE,EAE/CG,GAAUA,EAAO,aACVA,EAAA,WAAW,YAAYA,CAAM,EAChC1B,EAAM,SAAW,GACJK,EAAA,EAGzB,CCtOA,eAAsBsB,GAAqBjC,EAA+C,CAClF,OAAO,UAAY,SACnB,QAAQ,IAAI,6BAA6B,EAG7C,IAAIkC,EAAW,EACf,MAAMC,EAAmB,KACnBC,EAAY,KAAK,IAAI,EAG3B,SAASC,GAAyB,CACxB,MAAAC,EAAc,KAAK,IAAA,EAAQF,EACjCF,EAAW,KAAK,IAAI,GAAKI,EAAcH,EAAoB,GAAG,EAClDlD,EAAA,MAAM,MAAQ,GAAGiD,CAAQ,IACrChD,EAAa,UAAY,GAAG,KAAK,MAAMgD,CAAQ,CAAC,IAE5CA,GAAY,IACZ,cAAcK,CAAQ,CAC1B,CAGE,MAAAA,EAAW,YAAYF,EAAkB,GAAG,EAE9C,OAAO,UAAY,SACX,QAAA,IAAI,qCAAsCrC,CAAQ,EAG1D,GAAA,CACM,MAAAC,EAAW,MAAM,MAAM,cAAe,CACxC,OAAQ,OACR,QAAS,CACL,eAAgBL,EAChB,OAAU,kBACd,EACA,KAAMI,CAAA,CACT,EAID,GAFA,cAAcuC,CAAQ,EAElBtC,EAAS,GAAI,CACP,MAAAuC,EAAwB,YAAY,IAAM,CAChCN,GAAA,GACAjD,EAAA,MAAM,MAAQ,GAAGiD,CAAQ,IACrChD,EAAa,UAAY,GAAG,KAAK,MAAMgD,CAAQ,CAAC,IAE5CA,GAAY,KACZ,cAAcM,CAAqB,GAExC,EAAE,EAECC,EAAO,MAAMxC,EAAS,KAAK,EAEjC,GAAIwC,EACO,MAAA,CAAE,SAAAxC,EAAU,KAAAwC,CAAK,EAElB,MAAA,IAAI,MAAM,gCAAgC,CACpD,KACG,CACG,MAAAA,EAAO,MAAMxC,EAAS,KAAK,EAC1B,MAAA,CAAE,SAAAA,EAAU,KAAAwC,CAAK,CAAA,QAEvBtC,EAAY,CACjB,oBAAcoC,CAAQ,EAEhBpC,CAAA,CAEd,CASA,eAAsBuC,GAAgB1C,EAAsC,CACxE,MAAMD,EAAkBC,CAAQ,EAGhC,KAAM,CAAE,SAAAC,EAAU,KAAAwC,CAAS,EAAA,MAAMR,GAAqBjC,CAAQ,EAS1D,GAPJ,MAAMI,EAAyBJ,EAAS,IAAI,MAAM,CAAS,EAEvD,OAAO,UAAY,UACX,QAAA,IAAI,aAAaC,CAAQ,EAAE,EACnC,QAAQ,IAAI,SAAS,KAAK,UAAUwC,CAAI,CAAC,EAAE,GAG3C,CAACxC,EAAS,GAAI,CAEV,GAAAA,EAAS,SAAW,IACJ,OAAAiB,EAAAuB,EAAK,YAAa,OAAO,EAClC,GAIL,MAAAA,CAAA,CAIH,MAAA,EACX,CC9GA,eAAsBE,EAAUvB,EAA6B,CACnD,MAAAH,EAAsB,SAAS,cAAc,KAAK,EAClDlC,EAAyB,SAAS,eAAe,QAAQ,EAC3DkC,EAAA,UAAU,IAAI,WAAY,OAAO,EAErC,IAAI2B,EAAmB,GACnBC,EAAsB,GACtBC,EAAkB,GAClB5C,EAAiB,GAErB,GAAIkB,IAAS,UACT0B,EAAW,OAAe,WACjB5C,EAAA,KACE0C,EAAA,gEACGC,EAAA,mGACPzB,IAAS,YAChB0B,EAAW,OAAe,SAC1B5C,EAAS,OAAO,UACL0C,EAAA,+DACGC,EAAA,kGACPzB,IAAS,kBAChB0B,EAAW,OAAe,WAC1B5C,EAAS,OAAO,gBACL0C,EAAA,8DACGC,EAAA,6FAER,OAAA,IAAI,MAAM,iBAAiB,EAG/B,MAAAE,EAAoB,OAAO,WAAW,IAAM,CAC9C9B,EAAI,UAAY;AAAA;AAAA,mDAE2Bf,CAAM;AAAA;AAAA,UAGjDnB,EAAU,YAAYkC,CAAG,GAC1B,GAAI,EAEH,GAAA,EAC2B,MAAM,MAAM2B,EAAU,CAAE,OAAQ,OAAQ,GACrD,KACCA,EAAAC,QAEH,CACDD,EAAAC,CAAA,CAGf5B,EAAI,UAAY;AAAA;AAAA,wBAEI2B,CAAQ;AAAA,mBACbE,CAAO;AAAA;AAAA,qBAELA,CAAO;AAAA;AAAA;AAAA,MAKxB/D,EAAU,YAAYkC,CAAG,EACzB,aAAa8B,CAAS,CAC1B,CCrEO,MAAMC,CAAkB,CAG3B,aAAc,CACJ,MAAAC,EAAe,SAAS,cAAc,yBAAyB,EACrE,GAAI,CAACA,EAAoB,MAAA,IAAI,MAAM,gCAAgC,EACnE,KAAK,UAAYA,EAAa,aAAa,SAAS,GAAK,EAAA,CAS7D,MAAgB,cAAcC,EAAkBlD,EAA4G,CACxJ,IAAImD,EAAgC,KAChCC,EAAmB,GAEf,QAAA,IAAI,kCAAmCF,CAAQ,EAEnD,GAAA,CACM,MAAAjD,EAAqB,MAAM,MAAMiD,EAAU,CAC7C,OAAQ,OACR,QAAS,CACL,eAAgB,KAAK,UACrB,OAAU,kBACd,EACA,KAAMlD,CAAA,CACT,EAEG,GAAA,CAACC,EAAS,GAAI,CACd,MAAMoD,EAAcpD,EAAS,QAAQ,IAAI,cAAc,EAEnDoD,GAAeA,EAAY,SAAS,kBAAkB,EAC1CF,EAAA,MAAMlD,EAAS,KAAK,EAGpBkD,EAAA,CACR,QAAS,mDACT,QAHiB,MAAMlD,EAAS,KAAK,EAIrC,MAAO,UACP,UAAW,sBACX,SAAU,UACd,EAGMmD,EAAA,EAAA,CAGd,MAAO,CAAE,MAAOD,EAAW,SAAAlD,EAAU,QAAAmD,CAAQ,QACxCjD,EAAO,CAEA,OAAAgD,EAAA,CACR,QAAS,wCACT,QAAShD,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC9D,MAAO,UACP,UAAW,cACX,SAAU,UACd,EACO,CAAE,MAAOgD,EAAW,SAAU,GAAO,QAAS,EAAM,CAAA,CAC/D,CAOJ,MAAM,aAAa9C,EAAoG,CAE7G,MAAAL,EAAW,IAAI,SACZ,OAAAA,EAAA,OAAO,OAAQK,CAAI,EACrB,KAAK,cAAc,mBAAoBL,CAAQ,CAAA,CAE9D,CCxEO,MAAMsD,WAAyBN,CAAkB,CAGpD,aAAc,CACJ,MAAA,EAHV,KAAQ,YAAsB,CAAA,CAM9B,MAAM,aAAa3C,EAAoG,CAC7G,MAAAL,EAAW,IAAI,SACZA,EAAA,OAAO,OAAQK,CAAI,EACnBL,EAAA,OAAO,SAAU,KAAK,SAAS,EAC/BA,EAAA,OAAO,aAAc,KAAK,EAEnC,IAAIuD,EAAU,EACVpD,EAA4B,KAC5BF,EAA+B,GAC/BmD,EAAU,GAEd,KAAOG,EAAU,KAAK,aAAe,CAACH,GAAS,CAI3C,GAHAG,IACC,CAAE,MAAApD,EAAO,SAAAF,EAAU,QAAAmD,CAAA,EAAY,MAAM,KAAK,cAAc,cAAepD,CAAQ,EAE5EoD,EACA,eAAQ,IAAI,aAAaG,CAAO,cAAclD,EAAK,IAAI,EAAE,EAClD,CAAE,MAAAF,EAAO,SAAAF,EAAU,QAAAmD,CAAQ,EAElC,QAAQ,KAAK,aAAaG,CAAO,cAAapD,GAAA,YAAAA,EAAO,UAAW,oBAAoB,EAAE,EAGtF,CAACiD,GAAWG,EAAU,KAAK,aAC3B,QAAQ,IAAI,wBAAwBA,EAAU,CAAC,KAAK,CACxD,CAGG,MAAA,CAAE,MAAApD,EAAO,SAAAF,EAAU,QAAAmD,CAAQ,CAAA,CAE1C,CCpCO,MAAMI,WAAyBR,CAAkB,CACpD,MAAM,aAAa3C,EAAoG,CAC7G,MAAAL,EAAW,IAAI,SAGfyD,EAAgB,MAAM,KAAK,YAAYpD,CAAI,EACxC,OAAAL,EAAA,OAAO,OAAQyD,CAAa,EAC5BzD,EAAA,OAAO,SAAU,KAAK,SAAS,EAC/BA,EAAA,OAAO,aAAc,KAAK,EAG5B,MAAM,KAAK,cAAc,cAAeA,CAAQ,CAAA,CAM3D,MAAgB,cAAckD,EAAkBlD,EAA4G,CACxJ,IAAImD,EAAgC,KAChCC,EAAmB,GAEnB,GAAA,CACM,MAAAnD,EAAqB,MAAM,MAAMiD,EAAU,CAC7C,OAAQ,OACR,QAAS,CACL,eAAgB,KAAK,UACrB,OAAU,kBACd,EACA,KAAMlD,CAAA,CACT,EAEG,GAACC,EAAS,GAcP,CAEG,MAAAC,EAAS,MAAMD,EAAS,KAAK,GAC/B,CAACC,EAAO,mBAAqBA,EAAO,oBAAsB,WAChDkD,EAAA,GACED,EAAA,CACR,QAAS,wCACT,UAAW,eACf,EACJ,KAvBc,CACd,MAAME,EAAcpD,EAAS,QAAQ,IAAI,cAAc,EACnDoD,GAAeA,EAAY,SAAS,kBAAkB,EAC1CF,EAAA,MAAMlD,EAAS,KAAK,EAEpBkD,EAAA,CACR,QAAS,mDACT,QAAS,MAAMlD,EAAS,KAAK,EAC7B,MAAO,UACP,UAAW,sBACX,SAAU,UACd,EAEMmD,EAAA,EAAA,CAcT,YAAA,mBAAmBA,EAASD,CAAS,EAEnC,CAAE,MAAOA,EAAW,SAAAlD,EAAU,QAAAmD,CAAQ,QACxCjD,EAAO,CACA,OAAAgD,EAAA,CACR,QAAS,wCACT,QAAShD,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC9D,MAAO,UACP,UAAW,cACX,SAAU,UACd,EACO,CAAE,MAAOgD,EAAW,SAAU,GAAO,QAAS,EAAM,CAAA,CAC/D,CAMJ,MAAc,YAAY9C,EAA2B,CAE3C,MAAAqD,EAAc,MAAMrD,EAAK,YAAY,EACrCsD,EAAe,KAAK,OAAO,aAAa,GAAG,IAAI,WAAWD,CAAW,CAAC,CAAC,EACvEE,EAAgB,IAAI,KAAK,CAACD,CAAY,EAAG,CAAE,KAAMtD,EAAK,KAAM,EAE3D,OAAA,IAAI,KAAK,CAACuD,CAAa,EAAGvD,EAAK,KAAM,CAAE,KAAMA,EAAK,KAAM,CAAA,CAM3D,mBAAmB+C,EAAkBD,EAAqC,CAC1EC,EACA,QAAQ,IAAI,uCAAuC,EAE3C,QAAA,MAAM,wBAAyBD,CAAS,CACpD,CAER,CC/FO,MAAMU,WAA6Bb,CAAkB,CACxD,MAAM,aAAa3C,EAAoG,CAC7G,MAAAL,EAAW,IAAI,SACZ,OAAAA,EAAA,OAAO,OAAQK,CAAI,EACnBL,EAAA,OAAO,SAAU,KAAK,SAAS,EAC/BA,EAAA,OAAO,aAAc,SAAS,EAEhC,MAAM,KAAK,cAAc,kBAAmBA,CAAQ,CAAA,CAEnE,CCNO,MAAM8D,EAAkB,CAG3B,aAAc,CACV,KAAK,SAAW,CACZ,IAAO,IAAIR,GACX,IAAO,IAAIE,GACX,QAAW,IAAIK,GACf,QAAW,IAAIb,CACnB,CAAA,CAUH,MAAM,iBAAiB3C,EAAY0D,EAA4G,CAC5I,MAAMC,EAAU,KAAK,SAASD,CAAU,GAAK,KAAK,SAAS,QAE3D,QAAQ,IAAI,sCAAsCC,EAAQ,YAAY,IAAI,EAAE,EAExE,GAAA,CACM,KAAA,CAAE,MAAA7D,EAAO,SAAAF,EAAU,QAAAmD,GAAY,MAAMY,EAAQ,aAAa3D,CAAI,EAC7D,MAAA,CAAE,MAAAF,EAAO,SAAAF,EAAU,QAAAmD,CAAQ,QAC7BjD,EAAO,CAQZ,MAAO,CAAE,MAPsB,CAC3B,QAAS,4CACT,QAASA,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC9D,MAAO,UACP,UAAW,gBACX,SAAU,UACd,EAC2B,SAAU,GAAO,QAAS,EAAM,CAAA,CAC/D,CAER,CCqGA,eAAsB8D,IAA8B,CAC1C,MAAA3D,EAAQR,EAAS,GAAK,CAAC,EAMzB,GAJA,OAAO,UAAY,SACX,QAAA,IAAI,sBAAuBQ,EAAM,MAAM,EAG/CA,EAAM,SAAW,EAAG,CACpB,QAAQ,KAAK,6BAA6B,EAC1C,MAAA,CAGWC,EAAA,EACDzB,EAAA,UAAY,OAAO,eAAiB,MAE9C,IAAAoF,EAAa,IAAM5D,EAAM,OACzB6D,EAAe,GACfC,EAAa,EACbC,EAAoB,EACpBtD,EAAQ,EACRuD,EAAc,GAElB,UAAWjE,KAAQC,EAAO,CAChB,MAAAN,EAAW,IAAI,SACZA,EAAA,OAAO,OAAQK,CAAI,EACnBL,EAAA,OAAO,SAAUJ,CAAS,EACnCI,EAAS,OAAO,QAASe,EAAM,SAAA,CAAU,EAEnC,MAAAwD,EAAaxD,IAAUT,EAAM,OAAS,EAC5CN,EAAS,OAAO,WAAYuE,EAAa,OAAS,OAAO,EAErDA,GACAvE,EAAS,OAAO,aAAcoE,EAAW,SAAA,CAAU,EAGnD,GAAA,CAQA,GAPI,OAAO,UAAY,SACnB,QAAQ,IAAI,sBAAsB/D,EAAK,IAAI,EAAE,EAGjDrB,EAAiB,UAAY,GAGzBM,EAAU,UACUiC,EAAA,OAAO,aAAe,MAAO,MAAM,EAEvDvB,EAAS,OAAO,oBAAqBqE,EAAkB,SAAA,CAAU,EACxDrE,EAAA,OAAO,WAAYK,EAAK,IAAI,EAEjC,MAAMqC,GAAgB1C,CAAQ,GAAG,CAClBmE,EAAA,GACfC,IACAC,IACA7C,EAAwBnB,EAAK,IAAI,EAChBmE,EAAA,EACjB,QAAA,CAKF,MAAAT,EAAaU,GAAoBC,IAAkB,EAEjD,QAAA,IAAI,sBAAsBX,CAAU,EAAE,EAGxC,MAAAY,EAAoB,IAAIb,GAExB,CAAE,MAAA3D,EAAO,SAAAF,EAAU,QAAAmD,CAAA,EAAY,MAAMuB,EAAkB,iBAAiBtE,EAAM0D,CAAU,EAE9F,GAAKX,GAsBD,GANI,OAAO,UAAY,SACnB,QAAQ,IAAI,sBAAsB/C,EAAK,IAAI,EAAE,EAGjD0B,EAAU1B,EAAK,IAAI,EAEfJ,aAAoB,SAAU,CACxB,MAAA2E,EAAiB,MAAM3E,EAAS,KAAK,EAC3CiB,EAAgB0D,EAAe,aAAeC,GAAuBxE,EAAK,IAAI,EAAG,SAAS,EAC1FyE,GAAkB/D,EAAOmD,CAAU,CAAA,UAxBnC/D,GAAA,MAAAA,EAAO,SAMH,GALI,QAAA,MAAM,sBAAuBA,EAAM,OAAO,EAClDmE,EAAcnE,EAAM,aAAe,qBACpBgE,EAAA,GACfC,IACAlD,EAAgBoD,EAAa,OAAO,EAChCnE,EAAM,WAAa,WAAY,WAE3B,QAAA,MAAM,8BAAgCA,CAAK,EACnDmE,GAAcnE,GAAA,YAAAA,EAAO,cAAe,yBACrBgE,EAAA,GACfC,IACAlD,EAAgBoD,EAAa,OAAO,QAgBvCnE,EAAO,CACGgE,EAAA,GAEX,OAAO,UAAY,SACX,QAAA,MAAM,4BAA4BhE,CAAK,EAAE,EAI/C,MAAA4E,EAA2B5E,aAAiB,MAAQ,CACtD,QAASA,EAAM,QACf,QAASA,EAAM,MAGf,SAAU,UAAA,EACVA,EAEA,GAAA4E,EAAY,WAAa,WAAY,CACjBxD,EAAAwD,EAAY,aAAe,kCAAmC,OAAO,EACzFX,EAAa9D,EAAM,OACnB,KAAA,MAEAgE,EAAcS,EAAY,aAAe,0BACzB7D,EAAA,GAAGoD,CAAW,IAAI,OAAO,EAAE,IAAIjE,EAAK,IAAI,GAAI,OAAO,EACnEkB,EAAoB+C,EAAa,OAAO,EACxCF,IACiBI,EAAA,CACrB,CAEJzD,GAAA,CAGJiE,GAAeb,EAAcC,CAAU,CAC3C,CAOA,SAASK,GAAoBQ,EAA6B,CAEtD,MADmB,CAAC,MAAO,MAAO,SAAS,EACzB,SAASA,CAAW,EAAIA,EAAc,SAC5D,CAMA,SAASP,IAA2B,CAC1B,MAAAQ,EAAc,OAAO,SAAS,SACpC,OAAIA,EAAY,SAAS,aAAa,EAAU,MAC5CA,EAAY,SAAS,aAAa,EAAU,MAC5CA,EAAY,SAAS,iBAAiB,EAAU,UAC7C,SACX,CAOA,SAASJ,GAAkB/D,EAAemD,EAA0B,CAChEjF,EAAY,MAAM,MAAQ,IAAI8B,EAAQ,GAAKmD,CAAU,IACrDhF,EAAa,UAAY,GAAG,KAAK,OAAO6B,EAAQ,GAAKmD,CAAU,CAAC,GACpE,CAKA,SAASM,GAAyB,CAC9BvF,EAAY,MAAM,MAAQ,IAC1BC,EAAa,UAAY,EAC7B,CAQgB,SAAA8F,GAAeb,EAAuBC,EAA0B,CAC/DzD,EAAA,EAEP,MAAAL,EAAQR,EAAS,GAAK,CAAC,EAEzBqE,GAAgBC,IAAe,EAC/BzB,EAAU,SAAS,EACZ,CAACwB,GAAgBC,EAAa,GAAKA,EAAa9D,EAAM,OAC7DqC,EAAU,WAAW,EACd,CAACwB,GAAgBC,IAAe9D,EAAM,SAC7CqC,EAAU,iBAAiB,EACPpB,EAAA,OAAO,gBAAiB,OAAO,EAE3D,CASO,SAASsD,GAAuBM,EAA0B,CAEtD,OADiB,OAAO,8BACR,QAAQ,gBAAiBA,CAAQ,CAC5D,CC1VI,OAAO,UAAY,SACnB,QAAQ,IAAI,mCAAmC,EAU5C,SAASC,GAAa/E,EAA8B,OACjD,MAAAgF,GAAYC,EAAAjF,EAAK,KAAK,MAAM,GAAG,EAAE,QAArB,YAAAiF,EAA4B,cAE9C,GAAI,CAAC,OAAO,kBAAkB,SAASD,CAAU,EAAG,CAChD,MAAME,EAAwB,OAAO,kBAAkB,KAAK,IAAI,EAC1DC,EAAe,OAAO,yBACvB,QAAQ,aAAcH,CAAU,EAChC,QAAQ,cAAeE,CAAqB,EAGjD,OAAAE,EAAK,KAAK,CACN,MAAO,OAAO,gCACd,KAAMD,EACN,KAAM,QACN,kBAAmB,IAAA,CACtB,EAEM,CAAE,QAAS,GAAO,QAASA,CAAa,CAAA,CAGnD,GAAI,CAAC,OAAO,iBAAiB,SAASnF,EAAK,IAAI,EAAG,CACxC,MAAAmF,EAAe,OAAO,wBACvB,QAAQ,QAASnF,EAAK,IAAI,EAC1B,QAAQ,aAAc,OAAO,2BAA2B,EAG7D,OAAAoF,EAAK,KAAK,CACN,MAAO,OAAO,+BACd,KAAMD,EACN,KAAM,QACN,kBAAmB,IAAA,CACtB,EAEM,CAAE,QAAS,GAAO,QAASA,CAAa,CAAA,CAG/C,GAAAnF,EAAK,KAAO,OAAO,QAAS,CAEtB,MAAAmF,EAAe,OAAO,eAAe,QAAQ,SAAU,OAAO,QAAU,MAAM,UAAU,EAG9F,OAAAC,EAAK,KAAK,CACN,MAAO,OAAO,4BACd,KAAMD,EACN,KAAM,QACN,kBAAmB,IAAA,CACtB,EAEM,CAAE,QAAS,GAAO,QAASA,CAAa,CAAA,CAGnD,GAAI,CAACE,GAAiBrF,EAAK,IAAI,EAAG,CAC9B,MAAMmF,EAAe,OAAO,uBAAuB,QAAQ,YAAanF,EAAK,IAAI,EAGjF,OAAAoF,EAAK,KAAK,CACN,MAAO,OAAO,4BACd,KAAMD,EACN,KAAM,QACN,kBAAmB,IAAA,CACtB,EAEM,CAAE,QAAS,GAAO,QAASA,CAAa,CAAA,CAG5C,MAAA,CAAE,QAAS,EAAK,CAC3B,CAGO,SAASE,GAAiB7D,EAA2B,CAEjD,MADO,cACD,KAAKA,CAAQ,CAC9B,CCtCA,eAAsB8D,EAAwBrF,EAAgC,CAK5DxB,EAAA,UAAY,OAAO,eAAiB,MAClDC,EAAU,UAAY,GACtBC,EAAiB,UAAY,GAGhB,IAAMsB,EAAM,OACVC,EAAA,EACHK,EAAA,EAGZ,QAASJ,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CAC7B,MAAAH,EAAOC,EAAME,CAAC,EACLH,EAAK,KACpBpB,EAAY,MAAM,MAAQ,KAEtB,GAAA,CAEcH,EAAA,UAAY,OAAO,QAAU,MAG/BgC,EAAAN,EAAG,CAAE,OAAQ,CAAE,OAAQ,IAAI,gBAAgBH,CAAI,EAAI,EAAGC,CAAK,EAGvE,QAASsF,EAAI,EAAGA,EAAItF,EAAM,OAAQsF,IAAK,CAC7B,MAAA/D,EAAWvB,EAAMsF,CAAC,EAAE,KACpBC,EAAe,SAAS,eAAe,UAAUhE,CAAQ,EAAE,EAC7DgE,GACaA,EAAA,UAAU,OAAO,QAAQ,CAC1C,CAIUnF,EAAA,EACN,QAAA,IAAI,wBAAyB,OAAO,kBAAkB,EAG1DpB,EAAU,QACVR,EAAc,UAAY,OAAO,kBAEjCA,EAAc,UAAY,OAAO,yBAGhCoB,EAAa,CAElB,IAAIoE,EAAsBpE,EAAO,YAE7B,OAAO,UAAY,UACnB,QAAQ,IAAI,6BAA6B,EACjC,QAAA,IAAI,cAAeoE,CAAW,GAE1CpD,EAAgB,GAAGb,EAAK,IAAI,KAAKiE,CAAW,GAAI,OAAO,EACvD/C,EAAoB+C,EAAa,OAAO,CAAA,CAC5C,CAER,CCvFO,SAASwB,IAAoC,CAChD,OAAO,KAAK,QAAQ,QAAQ,EAC3B,OAAO,uBAAyB,GAAmB,CAClD,OAAQ,EAAE,MAAO,CACf,IAAK,6BACHC,EAAS,EAAG,SAAS,EACDxE,EAAA,EAAE,QAAS,SAAS,EACxC,cAAc,OAAO,YAAY,EACjC,MACF,IAAK,eACHwE,EAAS,EAAG,SAAS,EACDxE,EAAA,EAAE,QAAS,SAAS,EACxC,cAAc,OAAO,YAAY,EACjC,MACF,IAAK,eACHwE,EAAS,EAAG,OAAO,EACCxE,EAAA,EAAE,QAAS,OAAO,EACtC,cAAc,OAAO,YAAY,EACjC,MACF,IAAK,wBACHwE,EAAS,EAAG,SAAS,EACDxE,EAAA,EAAE,QAAS,SAAS,EACxC,cAAc,OAAO,YAAY,EACjC,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,OAC7D,MACF,IAAK,4BACHwE,EAAS,EAAG,SAAS,EACDxE,EAAA,EAAE,QAAS,SAAS,EACxC,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,OAC7D,MACF,IAAK,6BACHwE,EAAS,EAAG,SAAS,EACDxE,EAAA,EAAE,QAAS,SAAS,EACxC,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,OAC7D,MACF,IAAK,mBACHwE,EAAS,EAAG,OAAO,EACCxE,EAAA,EAAE,QAAS,OAAO,EACtC,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,OAC7D,MACF,IAAK,2BACHwE,EAAS,EAAG,OAAO,EACCxE,EAAA,EAAE,QAAS,OAAO,EACtC,MACF,IAAK,YACHwE,EAAS,EAAG,MAAM,EAClB,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,QAC7D,SAAS,eAAe,gBAAgB,EAAG,UAAY,EAAE,QACzD,MACF,IAAK,eACHA,EAAS,EAAG,MAAM,EAClB,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,OAC7D,SAAS,eAAe,gBAAgB,EAAG,UAAY,EAAE,QACzD,MACF,IAAK,aACHA,EAAS,EAAG,MAAM,EACExE,EAAA,EAAE,QAAS,MAAM,EACrC,MACF,IAAK,kBACHwE,EAAS,EAAG,MAAM,EAClB,MACF,IAAK,QACHA,EAAS,EAAG,OAAO,EACnB,MACF,IAAK,WACHA,EAAS,EAAG,OAAO,EACCxE,EAAA,EAAE,QAAS,OAAO,EACtC,cAAc,OAAO,YAAY,EACjC,SAAS,eAAe,eAAe,EAAG,MAAM,WAAa,wCAC7D,SAAS,eAAe,oBAAoB,EAAG,UAAY,OAAO,kBAClE,SAAS,eAAe,kBAAkB,EAAG,MAAM,QAAU,OAC7D,MACF,IAAK,OACHwE,EAAS,EAAG,MAAM,EACExE,EAAA,EAAE,QAAS,MAAM,EACrC,MACF,QACEwE,EAAS,EAAG,MAAM,EAClB,KAAA,CACJ,CACD,CACL,CAQA,SAASA,EAAS,EAAgB3E,EAAoB,CAChD,OAAO,UAAY,UACrB,QAAQ,IAAI,eAAeA,CAAI,GAAI,CAAC,EACpC,QAAQ,IAAI,YAAY,EAAE,OAAO,EAAE,EAEvC,CCjFA,SAAS4E,EAAW1F,EAAiC,CACjD,GAAI,CAACA,EACM,MAAA,GAGX,QAASE,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CACnC,MAAMyF,EAAmBb,GAAa9E,EAAME,CAAC,CAAC,EAC1C,GAAA,CAACyF,EAAiB,QACV,eAAA,MAAM,QAAQ3F,EAAME,CAAC,EAAE,IAAI,wCAAwCyF,EAAiB,OAAO,EAAE,EAC9F,EACX,CAEG,MAAA,EACX,CACA,QAAQ,IAAI,4BAA4B,EACxC,QAAQ,KAAK,mBAAmB,EAChC,SAAS,iBAAiB,mBAAoB,UAAY,CAEtD,OAAO,UAAYtD,EACnB,OAAO,YAAc7B,EACrB,OAAO,WAAac,EACpB,OAAO,iBAAmBsE,EAC1B,OAAO,aAAejC,GACtB,OAAO,WAAakC,EACpB,OAAO,qBAAuBC,EAC9B,OAAO,aAAezF,EACtB,OAAO,aAAe0F,EAEd,QAAA,IAAI,oBAAqB,OAAO,iBAAiB,EACjD,QAAA,IAAI,mBAAoB,OAAO,gBAAgB,EAC/C,QAAA,IAAI,UAAW,OAAO,OAAO,EAEjC,OAAO,UAAY,UAEX,QAAA,IAAI,oBAAqB,OAAO,iBAAiB,EACjD,QAAA,IAAI,mBAAoB,OAAO,gBAAgB,EAC/C,QAAA,IAAI,UAAW,OAAO,OAAO,EAErC,QAAQ,IAAI,4BAA4B,GAGxC,OAAO,UAAY,SACX,QAAA,IAAI,cAAe,OAAO,SAAS,EAG/CrH,EAAiB,UAAY,GAGD8G,GAAA,EAE5B7G,EAAY,MAAM,MAAQ,IAC1BC,EAAa,UAAY,GAErB,OAAO,UAAY,UACX,QAAA,IAAI,OAAO,kBAAkB,EAC7B,QAAA,IAAI,4BAA6B,OAAO,wBAAwB,EAChE,QAAA,IAAI,gCAAiC,OAAO,4BAA4B,EACxE,QAAA,IAAI,2BAA4B,OAAO,uBAAuB,GAIhEI,EAAA,iBAAiB,QAAS,UAAW,CACvCA,EAAU,SACKD,EAAA,UAAU,OAAO,cAAc,EAC/BA,EAAA,UAAU,IAAI,gBAAgB,EAC7CA,EAAe,UAAY,OAAO,oBAClCE,EAAY,MAAM,QAAU,QAChBA,EAAA,UAAU,IAAI,cAAc,EACxCA,EAAY,UAAY,OAAO,kBAEhBF,EAAA,UAAU,OAAO,gBAAgB,EACjCA,EAAA,UAAU,IAAI,cAAc,EAC3CA,EAAe,UAAY,OAAO,qBAClCE,EAAY,MAAM,QAAU,OAChC,CACH,EAGD,SAAS6G,GAA6B,CAG3B,OAAA,SAAS,KAAO,OAAO,uBAAA,CAIlC,eAAeF,EAAiBlF,EAA6B,CAEzD,QAAQ,IAAI,yBAAyB,EAGrC,MAAMV,EAAQR,EAAS,EACnBkG,EAAW1F,CAAK,GAChB,MAAMqF,EAAwBrF,CAAM,CACxC,CAIJ,eAAe6F,EAAWnF,EAAiC,OACvDA,EAAM,eAAe,EACf,MAAAV,GAAQgF,EAAAtE,EAAM,eAAN,YAAAsE,EAAoB,MAC9BhF,GAAS0F,EAAW1F,CAAK,GACzB,MAAMqF,EAAwBrF,CAAK,CACvC,CAIJ,eAAe+F,GAA8B,CAEzC,IAAIC,EAAoB,GAExB,MAAMhG,EAAQR,EAAS,EACvB,GAAIQ,EACA,UAAWD,KAAQC,EACXD,GAAQA,EAAK,MACb0B,EAAU1B,EAAK,IAAI,EAK3B,GAAA,CACgB,MAAMkG,EAAsB,IAEpBD,EAAA,SAEZ,CACQA,EAAA,EAAA,CAGX3F,EAAA,EACJ,SAAA,eAAe,YAAY,EAAG,UAAY,GACnD1B,EAAY,MAAM,MAAQ,KAC1BC,EAAa,UAAY,GACzBJ,EAAc,UAAY,8BAC1BC,EAAU,UAAY,EAAA,CAG1B,QAAQ,IAAI,2BAA2B,EACvC,QAAQ,QAAQ,mBAAmB,CAEvC,CAAC,EAED,OAAO,iBAAiB,eAAgB,eAAgB,EAAsB,CAC1E,IAAIuH,EAAoB,GAEpB,GAAA,CACgB,MAAMC,EAAsB,IAEpBD,EAAA,SAEZ,CACQA,EAAA,EAAA,CAGpBA,IACA,EAAE,eAAe,EACjB,EAAE,YAAc,GAExB,CAAC,EAGD,eAAeC,GAA0C,CACrD,MAAM3G,EAAa,SAAS,cAAc,yBAAyB,EAAsB,aAAa,SAAS,EAC3G,GAAA,CAYI,GAAA,EAXa,MAAM,MAAM,2BAA4B,CACrD,OAAQ,OACR,QAAS,CACL,eAAgB,mBAChB,eAAgBA,GAAa,EACjC,EACA,KAAM,KAAK,UAAU,CACjB,WAAY,OAAO,eACtB,CAAA,CAAA,CACJ,GAEa,GACJ,MAAA,IAAI,MAAM,mCAAmC,EAGvD,eAAQ,IAAI,uCAAuC,EAC5C,SACFO,EAAO,CACJ,eAAA,MAAM,mCAAoCA,CAAK,EAChD,EAAA,CAEf"}