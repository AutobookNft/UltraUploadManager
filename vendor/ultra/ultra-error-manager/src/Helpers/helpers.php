<?php

declare(strict_types=1); // Ensure strict types are enforced

// Import interfaces/classes for type hinting and container resolution keys
use Ultra\ErrorManager\Interfaces\ErrorManagerInterface;
use Ultra\ErrorManager\Services\TestingConditionsManager;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;

if (!function_exists('ultra_error')) {
    /**
     * Global helper function to handle an error via the UltraErrorManager service.
     *
     * Resolves the ErrorManagerInterface instance from the service container
     * and delegates the call to its handle() method.
     *
     * @param string $errorCode The symbolic error code (e.g., 'VALIDATION_ERROR').
     * @param array<string, mixed> $context Additional context data for the error event.
     * @param \Throwable|null $exception The original exception, if available.
     * @param bool $throw If true, forces an UltraErrorException to be thrown (default: false).
     * @return \Illuminate\Http\JsonResponse|\Illuminate\Http\RedirectResponse|null The response generated by the ErrorManager, or null.
     * @throws \Ultra\ErrorManager\Exceptions\UltraErrorException If $throw is true or for fatal fallback errors within handle().
     */
    function ultra_error(
        string $errorCode,
        array $context = [],
        ?\Throwable $exception = null,
        bool $throw = false // Added $throw parameter for consistency with interface
    ): JsonResponse|RedirectResponse|null { // Added return type hint
        // Resolve the service instance from the container
        /** @var ErrorManagerInterface $errorManager */
        $errorManager = app(ErrorManagerInterface::class); // Use interface for resolution

        // Call the handle method on the resolved instance
        return $errorManager->handle($errorCode, $context, $exception, $throw);
    }
}

if (!function_exists('simulate_error')) {
    /**
     * Global helper function to ACTIVATE or DEACTIVATE a testing/simulation condition.
     *
     * Resolves the TestingConditionsManager instance from the service container
     * and calls its setCondition() method. Useful for setting up test states.
     *
     * @param string $conditionCode The code of the condition/error to simulate (e.g., 'UCM_NOT_FOUND').
     * @param bool $active Set to true to activate the simulation, false to deactivate (default: true).
     * @return void This function does not return a value.
     */
    function simulate_error(string $conditionCode, bool $active = true): void
    {
        // Resolve the service instance from the container
        /** @var TestingConditionsManager $conditionsManager */
        $conditionsManager = app(TestingConditionsManager::class);

        // Call the setCondition method on the resolved instance
        $conditionsManager->setCondition($conditionCode, $active);
    }
}

if (!function_exists('is_simulating_error')) {
    /**
     * Global helper function to CHECK if a specific testing/simulation condition is active.
     *
     * Resolves the TestingConditionsManager instance from the service container
     * and calls its isTesting() method. Considers both the specific condition flag
     * and the global testing enabled state.
     *
     * @param string $conditionCode The code of the condition/error to check.
     * @return bool True if the condition is active AND testing is globally enabled.
     */
    function is_simulating_error(string $conditionCode): bool
    {
        // Resolve the service instance from the container
        /** @var TestingConditionsManager $conditionsManager */
        $conditionsManager = app(TestingConditionsManager::class);

        // Call the isTesting method on the resolved instance
        return $conditionsManager->isTesting($conditionCode);
    }
}

if (!function_exists('get_active_error_simulations')) {
    /**
     * Global helper function to GET ALL currently active testing/simulation conditions.
     *
     * Resolves the TestingConditionsManager instance from the service container
     * and calls its getActiveConditions() method.
     *
     * @return array<string, true> An associative array of active condition codes (code => true).
     */
    function get_active_error_simulations(): array
    {
        // Resolve the service instance from the container
        /** @var TestingConditionsManager $conditionsManager */
        $conditionsManager = app(TestingConditionsManager::class);

        // Call the getActiveConditions method on the resolved instance
        return $conditionsManager->getActiveConditions();
    }
}

if (!function_exists('reset_error_simulations')) {
    /**
     * Global helper function to RESET ALL specific testing/simulation conditions.
     *
     * Resolves the TestingConditionsManager instance from the service container
     * and calls its resetAllConditions() method.
     * Note: This does not affect the global testing enabled state if manually set.
     *
     * @return void This function does not return a value.
     */
    function reset_error_simulations(): void
    {
        // Resolve the service instance from the container
        /** @var TestingConditionsManager $conditionsManager */
        $conditionsManager = app(TestingConditionsManager::class);

        // Call the resetAllConditions method on the resolved instance
        $conditionsManager->resetAllConditions();
    }
}